{"remainingRequest":"/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/src/components/flowchart/Flowchart.vue?vue&type=style&index=1&id=48307d11&lang=less&scoped=true&","dependencies":[{"path":"/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/src/components/flowchart/Flowchart.vue","mtime":1668160373879},{"path":"/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/css-loader/index.js","mtime":1660192274937},{"path":"/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1660192275629},{"path":"/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/postcss-loader/src/index.js","mtime":1660192275315},{"path":"/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/less-loader/dist/cjs.js","mtime":1660192275256},{"path":"/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":1660192275271},{"path":"/Users/ht.mi/个人资料/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/vue-loader/lib/index.js","mtime":1660192275522}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.query-btn{\n    position: absolute;\n    left: 5px;\n    bottom: 5px;\n    font-size: 0.8rem;\n    font-weight: bolder;\n    color: #808080;\n    line-height: 10px;\n    // background: #fff;\n    // border: 1px solid #dcdfe6;\n    // cursor: pointer;\n    // border-radius: 4px;\n    // &.selected {\n    // color: #409eff;\n    // border-color: #c6e2ff;\n    // background-color: #ecf5ff;\n    // }\n    //  &.hover {\n    // color: #409eff;\n    // border-color: #c6e2ff;\n    // background-color: #ecf5ff;\n    // }\n  \n}\npath {\n    &.highlighted {\n        stroke: red;\n    }\n}\n\n",{"version":3,"sources":["Flowchart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0wDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"Flowchart.vue","sourceRoot":"src/components/flowchart","sourcesContent":["<template>\n  <div\n    id=\"chart\"\n    tabindex=\"0\"\n    :style=\"{ cursor: cursor }\"\n    @mousemove=\"handleChartMouseMove\"\n    @mouseup=\"handleChartMouseUp\"\n    @mousewheel=\"handleChartMouseWheel\"\n    @mousedown=\"handleChartMouseDown($event)\">\n    <!-- <span id=\"position\" class=\"unselectable\">\n      {{ cursorToChartOffset.x + \", \" + cursorToChartOffset.y }}\n    </span> -->\n    <!-- <span v-if=\"regexContentFlag\" id=\"regexPosition\" class=\"unselectable\">\n      {{\"regexContent: \" + regexContent}}\n    </span> -->\n    <svg id=\"svg\" ref=\"flowChartCanvas\">\n      <rect class=\"selection\" height=\"0\" width=\"0\"></rect>\n    </svg>\n    <el-button class=\"query-btn\" size=\"mini\" @click=\"query\">Query</el-button>\n  </div>\n\n</template>\n<style lang=\"less\" src=\"./index.less\"></style>\n<script>\nimport { line2, lineTo } from \"../../utils/svg\";\nimport { mapState, mapMutations } from 'vuex'\nimport * as d3 from \"d3\";\n\nimport {\n  roundTo20,\n  between,\n  distanceOfPointToLine, \n  getEdgeOfPoints,\n  pointRectangleIntersection,\n} from \"../../utils/math\";\nimport render from \"./render\";\n\nexport default {\n  name: \"flowchart\",\n  props: {\n    nodes: {\n      type: Array,\n      default: () => [],\n    },\n    connections: {\n      type: Array,\n      default: () => [],\n    },\n    width: {\n      type: [String, Number],\n      default: 800,\n    },\n    height: {\n      type: [String, Number],\n      default: 600,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n    excludeShownAttrArray: {\n      type: Array,\n      default: [],\n    }\n  },\n  data() {\n    return {\n      internalNodes: [],\n      internalConnections: [],\n      connectingInfo: {\n        source: null,\n        sourcePosition: null,\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: { x: 0, y: 0 },\n      clickedOnce: false,\n      pathClickedOnce: false,\n      /**\n       * lines of all internalConnections\n       */\n      lines: [],\n      canvasId: \"svg\",\n      regexContent: \"\",\n      regexContentFlag: false,\n    };\n  },\n  watch: {\n    conditionState: function(){\n      console.log(\"conditionState\")\n    }\n  },\n  computed: {\n    ...mapState([\n      'regexContentState',\n      'curRegexIndex',\n      'selectedDomKey',\n      'selectedDom',\n      'visPanelState'\n    ]),\n  },\n  methods: {\n    ...mapMutations([\n      'UPDATE_VISVIEW',\n      'UPDATE_CURRENT_REGEX',\n      'UPDATE_CONNECTION',\n      'UPDATE_SELECTED_DOM',\n      'UPDATE_CONDITION_STATE',\n      'GET_SELECTEDKEY',\n      'DATA_QUERY_REGEX',\n      'UPDATE_NODE_DEFINITION_STATE'\n    ]),\n\n    query(){\n      var edgeInfo = sysDatasetObj.getEdgeInfo()\n      console.log(\"edgeInfo: \", edgeInfo)\n      var rootNode = {\n        'type': 'node',\n        'repeat': [1 ,1],\n        'data': {\n\n        },\n        'children':[\n\n        ]\n      }\n      for(let i=0; i<this.internalNodes.length; i++){\n        this.internalNodes[i]['regex']['children'] = []\n      }\n      for(let i=0; i<edgeInfo.length; i++){\n        var curI = null\n        var curJ = null\n        for(let i1=0; i1<this.internalNodes.length; i1++){\n          if(edgeInfo[i][0] == this.internalNodes[i1]['regexIndex']){\n            curI = this.internalNodes[i1]['regex']  \n          }\n          if(edgeInfo[i][1] == this.internalNodes[i1]['regexIndex']){\n            curJ = this.internalNodes[i1]['regex']  \n          }\n        }\n        curI['children'].push(curJ)\n      }\n      if(edgeInfo.length == 0 && this.internalNodes.length == 1){\n        rootNode = this.internalNodes[0]['regex']\n      }\n      for(let i=0; i<edgeInfo.length; i++){\n        var flag = 1\n        for(let j=0; j<edgeInfo.length; j++){\n          if(edgeInfo[i][0] == edgeInfo[j][1]){\n            flag = -1\n            break\n          }\n        }\n        if(flag != -1){\n          for(let k=0; k<this.internalNodes.length; k++){\n            if(this.internalNodes[k]['regexIndex'] == edgeInfo[i][0]){\n              rootNode = this.internalNodes[k]['regex']\n              break\n            }\n          }\n          break\n        }\n      }\n      sysDatasetObj.updateRegex(rootNode)\n      this.DATA_QUERY_REGEX()\n    },\n    add(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.internalNodes.push(node);\n    },\n    editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editnode\", node);\n    },\n    handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      if (event.ctrlKey) {\n        let svg = document.getElementById(\"svg\");\n        let zoom = parseFloat(svg.style.zoom || 1);\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    async handleChartMouseUp() {\n      if (this.connectingInfo.source) {\n        if (this.hoveredConnector) {\n          if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n            // Node can't connect to itself\n            let tempId = +new Date();\n            let conn = {\n              source: {\n                id: this.connectingInfo.source.id,\n                position: this.connectingInfo.sourcePosition,\n              },\n              destination: {\n                id: this.hoveredConnector.node.id,\n                position: this.hoveredConnector.position,\n              },\n              id: tempId,\n              type: \"pass\",\n              name: \"Pass\",\n            };\n            let tmpSource = this.internalNodes.filter((item) => item.id === conn['source']['id'])[0]\n            let tmpDestination = this.internalNodes.filter((item) => item.id === conn['destination']['id'])[0]\n            sysDatasetObj.addEdge(tmpSource['regexIndex'], tmpDestination['regexIndex'])\n            \n            this.internalConnections.push(conn)\n          }\n        }\n        this.connectingInfo.source = null;\n        this.connectingInfo.sourcePosition = null;\n      }\n      if (this.selectionInfo) {\n        this.selectionInfo = null;\n      }\n      this.regexContentFlag = false\n      \n    },\n    async handleChartMouseMove(event) {\n      // calc offset of cursor to chart\n      let svg = document.getElementById(\"svg\");\n      let zoom = svg.style.zoom; // the size ratio of the whole canvas\n      if (zoom.length == 0) {\n        zoom = 1\n      }\n      zoom = parseFloat(zoom)\n      let boundingClientRect = event.currentTarget.getBoundingClientRect();\n      let actualX = event.pageX - boundingClientRect.left - window.scrollX;  \n      actualX = actualX / zoom\n      this.cursorToChartOffset.x = Math.trunc(actualX);\n      let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n      actualY = actualY / zoom\n      this.cursorToChartOffset.y = Math.trunc(actualY);\n      if (this.connectingInfo.source) {\n        await this.renderConnections();\n\n        d3.selectAll(\"#svg .connector\").classed(\"active\", true);\n\n        let sourceOffset = this.getNodeConnectorOffset(\n          this.connectingInfo.source.id,\n          this.connectingInfo.sourcePosition\n        );\n        let destinationPosition = this.hoveredConnector\n          ? this.hoveredConnector.position\n          : null;\n        this.arrowTo(\n          sourceOffset.x,\n          sourceOffset.y,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y,\n          this.connectingInfo.sourcePosition,\n          false,\n          destinationPosition\n        );\n      }\n    },\n    handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n      sysDatasetObj.updateSelectedDomKey(-1)\n      this.UPDATE_NODE_DEFINITION_STATE()\n      this.selectionInfo = { x: event.offsetX, y: event.offsetY };\n    },\n    getConnectorPosition(node) {\n      //const halfWidth = node.width / 2;\n      const halfWidth = 20 + 5;\n      const halfHeight = node.height / 2;\n      let top = { x: node.x + halfWidth, y: node.y };\n      let left = { x: node.x, y: node.y + halfHeight };\n      let bottom = { x: node.x + halfWidth, y: node.y + node.height };\n      let right = { x: node.x + node.width, y: node.y + halfHeight };\n      return { left, right, top, bottom };\n    },\n    renderSelection() {\n      let that = this;\n      // render selection rectangle\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        let edge = getEdgeOfPoints([\n          { x: that.selectionInfo.x, y: that.selectionInfo.y },\n          { x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y },\n        ]);\n        let svg = d3.select(\"#svg\");\n        let rect = svg.select(\".selection\").classed(\"active\", true);\n        rect\n          .attr(\"x\", edge.start.x)\n          .attr(\"y\", edge.start.y)\n          .attr(\"width\", edge.end.x - edge.start.x)\n          .attr(\"height\", edge.end.y - edge.start.y);\n\n        that.internalNodes.forEach((item) => {\n          let points = [\n            { x: item.x, y: item.y },\n            { x: item.x, y: item.y + item.height },\n            { x: item.x + item.width, y: item.y },\n            { x: item.x + item.width, y: item.y + item.height },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge))\n          ) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach((line) => {\n          let points = [\n            { x: line.sourceX, y: line.sourceY },\n            { x: line.destinationX, y: line.destinationY },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge)) &&\n            that.currentConnections.every((item) => item.id !== line.id)\n          ) {\n            let connection = that.internalConnections.filter(\n              (conn) => conn.id === line.id\n            )[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        d3.selectAll(\"#svg > .selection\").classed(\"active\", false);\n      }\n    },\n    renderConnections() {\n      let that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          d3.selectAll(\"#svg > g.connection\").remove();\n          // render lines\n          that.lines = [];\n          that.internalConnections.forEach((conn) => {\n            let sourcePosition = that.getNodeConnectorOffset(\n              conn.source.id,\n              conn.source.position\n            );\n            let destinationPosition = that.getNodeConnectorOffset(\n              conn.destination.id,\n              conn.destination.position\n            );\n            let colors = {\n              pass: \"#888888\",\n              reject: \"red\",\n            };\n            let connectionSelected = that.currentConnections.filter((item) => item === conn).length > 0\n            if (connectionSelected) {\n              colors = {\n                pass: \"#888888\",\n                reject: \"darkred\",\n              };\n            }\n            let result = that.arrowTo(\n              sourcePosition.x,\n              sourcePosition.y,\n              destinationPosition.x,\n              destinationPosition.y,\n              conn.source.position,\n              conn.destination.position,\n              connectionSelected,\n              colors[conn.type]\n            );\n            for (const path of result.paths) {\n              path.on(\"mousedown\", function () {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(0, that.currentConnections.length);\n                that.currentConnections.push(conn);\n              });\n            }\n            for (const line of result.lines) {\n              that.lines.push({\n                sourceX: line.sourceX,\n                sourceY: line.sourceY,\n                destinationX: line.destinationX,\n                destinationY: line.destinationY,\n                id: conn.id,\n              });\n            }\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes() {\n      let that = this;\n      return new Promise(function (resolve) {\n        d3.selectAll(\"#svg > g.node\").remove();\n\n        // render nodes\n        that.internalNodes.forEach((node) => {\n          that.renderNode(\n            node,\n            that.currentNodes.filter((item) => item === node).length > 0\n          );\n        });\n\n        resolve();\n      });\n    },\n    getNodeConnectorOffset(nodeId, connectorPosition) {\n      let node = this.internalNodes.filter((item) => item.id === nodeId)[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append(element) {\n      let svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo(x1, y1, x2, y2) {\n      let g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo(x1, y1, x2, y2, startPosition, endPosition, connectionSelected, color) {\n      let g = this.append(\"g\");\n      g.classed(\"connection\", true);\n      if (connectionSelected) {\n        line2(g, x1, y1, x2, y2, startPosition, endPosition, 2.5, color || \"#a3a3a3\", true);\n      } else {\n        line2(g, x1, y1, x2, y2, startPosition, endPosition, 1, color || \"#a3a3a3\", true);\n      } \n      // a 5px cover to make mouse operation conveniently\n      return line2(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        5,\n        \"transparent\",\n        false\n      );\n    },\n    renderNode(node, isSelected) {\n      let that = this;\n      let g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n\n      node.render = render;\n      node.render(g, node, isSelected, this.excludeShownAttrArray);\n\n      let drag = d3\n        .drag()\n        .on(\"start\", function () {\n          // handle mousedown\n          let isNotCurrentNode =\n            that.currentNodes.filter((item) => item === node).length === 0;\n          if (isNotCurrentNode) {\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentNodes.push(node);\n          }\n          // the drag event and click event is conflicted, \n          // so handle the drag start function of the selected nodes is equal to the double click event\n          if (that.clickedOnce) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.editNode(node);\n          } else {\n\n            let timer = setTimeout(function () {\n              that.clickedOnce = false;\n              clearTimeout(timer);\n            }, 300);\n            that.clickedOnce = true;\n          }\n        })\n        .on(\"drag\", async function () {\n          if (that.readonly) {\n            return;\n          }\n\n          let zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n          for (let currentNode of that.currentNodes) {\n            currentNode.x += d3.event.dx / zoom;\n            currentNode.y += d3.event.dy / zoom;\n          }\n\n          d3.selectAll(\"#svg > g.guideline\").remove();\n          let edge = that.getCurrentNodesEdge();\n          let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n          let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n          that.internalNodes.forEach((item) => {\n            if (\n              that.currentNodes.filter((currentNode) => currentNode === item)\n                .length === 0\n            ) {\n              if (item.x === expectX) {\n                // vertical guideline\n                if (item.y < expectY) {\n                  that.guideLineTo(\n                    item.x,\n                    item.y + item.height,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX,\n                    expectY + item.height,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n              if (item.y === expectY) {\n                // horizontal guideline\n                if (item.x < expectX) {\n                  that.guideLineTo(\n                    item.x + item.width,\n                    item.y,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX + item.width,\n                    expectY,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n            }\n          });\n        })\n        .on(\"end\", function () {\n          d3.selectAll(\"#svg > g.guideline\").remove();\n          for (let currentNode of that.currentNodes) {\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n        let isNotCurrentNode =\n          that.currentNodes.filter((item) => item === node).length === 0;\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n      if(node['regex']['type'] == 'node'){\n        var curX = node.x + 5\n        var curY = node.y + 5\n        var eleWidth = 5\n        var eleHeight = 5\n        if('notFlag' in node['regex'] && node['regex']['notFlag']){\n          g.append('path')\n          .attr('d', function(){\n            var x1 = curX-3\n            var y1 = curY+5\n        \n            return ( \"M \" + x1 + \" \" + y1 +\n                    \"v \" + 23);\n          })\n          .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n          g.append('circle')\n          .attr('cx', curX-3)\n          .attr('cy', curY+33)\n          .attr('r', '0.7')\n           .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n        \n        }\n\n        g.append('rect')\n        .attr('class', 'unselectable title')\n        .attr('id', 'rect'+node['regex']['key'])\n        .attr('x', curX)\n        .attr('y', curY)\n        .attr('width', 40)\n        .attr('height', 40)\n        .attr('style', function(){\n            let tmpKey = sysDatasetObj.getSelectedDomKey()\n            if(node['regex']['key'] === tmpKey){\n                return ( \n                        \"stroke: red !important;\" + \n                        \"fill: \" + node['regex']['nodeColor'] + \"; \"+\n                        \"stroke-dasharray: 0 0; \" + \n                        \"stroke-width: 1;\"\n                )\n            }\n            return (\n              \"stroke: #c4bbbb; !important;\" + \n              \"fill: \" + node['regex']['nodeColor'] + \"; \" + \n                \"stroke-dasharray: 0 0; \" + \n                \"stroke-width: 1;\"\n            )\n        })\n        .on('click', function(){\n          d3.select(this)\n          .attr('style', function(){\n                                 return (     \n                      \"stroke: red !important;\" + \n                      \"fill: \" + node['regex']['nodeColor'] + \"; \"+\n                      \"stroke-dasharray: 0 0; \" + \n                      \"stroke-width: 1;\"\n                    )\n          })\n          sysDatasetObj.updateSelectedDomKey(node['regex']['key'])\n          sysDatasetObj.updateSelectedOr(node['regex'], -1)\n          that.UPDATE_CONDITION_STATE(false)\n          that.UPDATE_SELECTED_DOM(node['regex'])\n        })\n        if('nodeName' in node['regex']){\n          if(node['regex']['nodeName'] == '.'){\n            g.append('text')\n            .attr('class', 'new11')\n            .attr('x', curX + 20)\n            .attr('y', curY + 12)\n            .attr('fill', 'white')\n            .attr('font-size', '50px')\n            .attr('text-anchor', \"middle\")\n            .attr(\"alignment-baseline\", \"middle\")\n            .attr('class', 'unselectable title')\n            .text(() => node['regex']['nodeName'])\n            .on('click', function(){\n              d3.select('#rect'+node['regex']['key'])\n                .attr('style', function(){\n                                      return (     \n                            \"stroke: red !important;\" + \n                            \"fill: \" + node['regex']['nodeColor'] + \"; \"+\n                            \"stroke-dasharray: 0 0; \" + \n                            \"stroke-width: 1;\"\n                          )\n                })\n              sysDatasetObj.updateSelectedDomKey(node['regex']['key'])\n              sysDatasetObj.updateSelectedOr(node['regex'], -1)\n              that.UPDATE_CONDITION_STATE(false)\n              that.UPDATE_SELECTED_DOM(node['regex'])\n            })\n          }\n          else{\n            g.append('text')\n            .attr('class', 'new11')\n            .attr('x', curX + 20)\n            .attr('y', curY + 20 + 2.5)\n            .attr('fill', 'white')\n            .attr('font-size', '20px')\n            .attr('text-anchor', \"middle\")\n            .attr(\"alignment-baseline\", \"middle\")\n            .attr('class', 'unselectable title')\n            .text(() => node['regex']['nodeName'])\n            .on('click', function(){\n              d3.select('#rect'+node['regex']['key'])\n                .attr('style', function(){\n                                      return (     \n                            \"stroke: red !important;\" + \n                            \"fill: \" + node['regex']['nodeColor'] + \"; \"+\n                            \"stroke-dasharray: 0 0; \" + \n                            \"stroke-width: 1;\"\n                          )\n                })\n              sysDatasetObj.updateSelectedDomKey(node['regex']['key'])\n              sysDatasetObj.updateSelectedOr(node['regex'], -1)\n              that.UPDATE_CONDITION_STATE(false)\n              that.UPDATE_SELECTED_DOM(node['regex'])\n            })\n          }\n          \n        }\n        node.width = eleWidth + 40 + 5\n        node.height = eleHeight + 40 + 5\n      }\n      else if(node['regex']['type'] == 'or'){\n        let eleWidth = 0\n        let curX = node.x\n        let curY = node.y\n        g.append('path')\n        .attr('class', 'path-'+node['regex']['key'])\n        .attr('d', function(){\n          var x1 = curX + 15\n          var y1 = curY + 2.5\n          var x2 = curX + 15\n          var y2 = curY + 44.5\n\n          var qx = x1-(y2-y1)/3\n          var qy = (y2+y1)/2\n\n          return ( \"M \" +  x1 + \" \" +  y1 +\n                \" Q \" + qx + \" \" + qy + \" \" + x2 + \" \" + y2 );\n        })\n        .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n\n        g.append('rect')\n        .attr('width', '18')\n        .attr('height', '42')\n        .attr('transform', function(){\n          var x1 = curX + 15\n          var y1 = curY + 2.5\n          var x2 = curX + 15\n          var y2 = curY + 44.5\n\n          var qx = x1-(y2-y1)/3 + 5\n          var qy = (y2+y1)/2\n          return `translate(${qx}, ${y1})`\n        })\n        .attr('opacity', '0')\n        .on('click', function(){\n           that.UPDATE_SELECTED_DOM(node['regex'])\n            d3.selectAll('.path-'+node['regex']['key'])\n              .attr('style', 'stroke: red; stroke-width: 2px; fill: none;')\n            })\n        curX = curX + 15\n        eleWidth += 15\n\n        for(let i in node['regex']['composition']){\n          if(i!=0){\n            g.append('path')\n            .attr('d', function(){\n              var x1 = curX+10\n              var y1 = curY+3\n    \t        return ( \"M \" +  x1 + \" \" +  y1 +\n         \t\t      \" v \" + 42);\n            })\n            .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n            curX += 10\n            eleWidth += 5\n          }\n            if('notFlag' in node['regex']['composition'][i] && node['regex']['composition'][i]['notFlag']){\n              g.append('path')\n              .attr('d', function(){\n                var x1 = curX+7\n                var y1 = curY+5\n            \n                return ( \"M \" + x1 + \" \" + y1 +\n                        \"v \" + 32);\n              })\n              .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n              g.append('circle')\n              .attr('cx', curX+7)\n              .attr('cy', curY+40)\n              .attr('r', '1')\n              .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n            \n              curX += 3\n              eleWidth += 3\n            }\n            g.append('rect')\n              .attr('class', 'unselectable title')\n              .attr('id', 'rect'+node['regex']['composition'][i]['key'])\n              .attr('x', curX+10)\n              .attr('y', curY+3)\n              .attr('width', 42)\n              .attr('height', 42)\n              .attr('style', function(){\n                  let tmpKey = sysDatasetObj.getSelectedDomKey()\n                  if('definition' in node['regex']['composition'][i]){\n                      if(node['regex']['composition'][i]['definition']){\n                          if(node['regex']['composition'][i]['key'] === tmpKey){\n                              return ( \n                                      \"stroke: red !important;\" + \n                                      \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                                      \"stroke-dasharray: 0 0; \" + \n                                      \"stroke-width: 1;\"\n                              )\n                          }\n                          return (\n                            \"stroke: #c4bbbb; !important;\" + \n                            \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \" + \n                              \"stroke-dasharray: 0 0; \" + \n                              \"stroke-width: 1;\"\n                          )\n\n                      }\n                  }\n                  if('key' in node['regex']['composition'][i] && node['regex']['composition'][i].key === tmpKey){\n                        return ( \"stroke: red !important; \"+                \n                          \"stroke-width: 2; \" + \n                          \"stroke-dasharray: 4 2;\" + \n                          \"fill: white; \");\n                  }\n                  return (\n                      \"stroke: #c4bbbb; \" + \n                      \"stroke-width: 2; \" + \n                      \"stroke-dasharray: 4 2;\" + \n                      \"fill: white; \"\n                  )\n              })\n              .on('click', function(){\n                d3.select(this)\n                .attr('style', function(){\n                    if('definition' in node['regex']['composition'][i]){\n                        if(node['regex']['composition'][i]['definition']){\n                          return (     \n                            \"stroke: red !important;\" + \n                            \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                            \"stroke-dasharray: 0 0; \" + \n                            \"stroke-width: 1;\"\n                          )\n                        }\n                    }\n                    return (\n                          \"stroke: red !important;\" + \n                          \"stroke-width: 2; \" + \n                          \"stroke-dasharray: 4 2;\" + \n                          \"fill: white; \"\n                      )\n                })\n                that.UPDATE_CONDITION_STATE(false)\n                that.UPDATE_SELECTED_DOM(node['regex']['composition'][i])\n                sysDatasetObj.updateSelectedOr(node['regex'], i)\n              })\n            if('nodeName' in node['regex']['composition'][i]){\n              g.append('text')\n              .attr('class', 'new11')\n              .attr('x', curX + 31)\n              .attr('y', curY + 24)\n              .attr('fill', 'white')\n              .attr('font-size', '18px !important')\n              .attr('text-anchor', \"middle\")\n              .attr(\"alignment-baseline\", \"middle\")\n              .attr('class', 'unselectable title')\n              .text(() => node['regex']['composition'][i]['nodeName'])\n              .on('click', function(){\n                  d3.select('#rect'+node['regex']['composition'][i]['key'])\n                  .attr('style', function(){\n                  if('definition' in node['regex']['composition'][i]){\n                      if(node['regex']['composition'][i]['definition']){\n                        return (     \n                          \"stroke: red !important;\" + \n                          \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                          \"stroke-dasharray: 0 0; \" + \n                          \"stroke-width: 1;\"\n                        )\n                      }\n                  }\n                  return (\n                      \"stroke: red !important;\" + \n                      \"stroke-width: 2; \" + \n                      \"stroke-dasharray: 4 2;\" + \n                      \"fill: white; \"\n                  )\n              })\n                that.UPDATE_CONDITION_STATE(false)\n                that.UPDATE_SELECTED_DOM(node['regex']['composition'][i])\n                sysDatasetObj.updateSelectedOr(node['regex'], i)\n              })\n            }\n            curX = curX + 52\n            eleWidth += 52\n            if(!(node['regex']['composition'][i]['repeat'][0] == 1 && node['regex']['composition'][i]['repeat'][1] == 1)){\n              g.append('text')\n              .attr('x', curX + 5)\n              .attr('y', curY + 2)\n              .attr('font-size', '15px')\n              .attr('alignment-baseline', 'hanging')\n              .text(() => node['regex']['composition'][i]['repeat'][0] + '..' + node['regex']['composition'][i]['repeat'][1])\n              curX = curX + 30\n              eleWidth += 30\n            }\n        }\n        g.append('path')\n          .attr('class', 'path-'+node['regex']['key'])\n          .attr('d', function(){\n            var x1 = curX + 10\n            var y1 = curY + 2.5\n            var x2 = curX + 10\n            var y2 = curY + 44.5\n\n            var qx = x1+(y2-y1)/3\n            var qy = (y2+y1)/2\n\n            return ( \"M \" +  x1 + \" \" +  y1 +\n                  \" Q \" + qx + \" \" + qy + \" \" + x2 + \" \" + y2 );\n          })\n          .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n          \n          g.append('rect')\n            .attr('width', '18')\n            .attr('height', '42')\n            .attr('transform', function(){\n              var x1 = curX + 10\n              var y1 = curY + 2.5\n              var x2 = curX + 10\n              var y2 = curY + 44.5\n\n              var qx = x1-5\n              var qy = (y2+y1)/2\n              return `translate(${qx}, ${y1})`\n            })\n            .attr('opacity', '0')\n            .on('click', function(){\n              that.UPDATE_SELECTED_DOM(node['regex'])\n                d3.selectAll('.path-'+node['regex']['key'])\n                  .attr('style', 'stroke: red; stroke-width: 2px; fill: none;')\n                })\n\n        curX = curX + 15\n        eleWidth += 15\n\n        if(!(node['regex']['repeat'][0] == 1 && node['regex']['repeat'][1] == 1)){\n              g.append('text')\n              .attr('x', curX + 5)\n              .attr('y', curY + 2)\n              .attr('font-size', '15px')\n              .attr('alignment-baseline', 'hanging')\n              .text(() => node['regex']['repeat'][0] + '..' + node['regex']['repeat'][1])\n              curX = curX + 30\n              eleWidth += 30\n        }\n\n        node.width = 15 + eleWidth\n\n      }\n      else if(node['regex']['type'] == 'branch'){\n        let eleWidth = 5\n        let eleHeight = 5\n        let curX = node.x + 5\n        let curY = node.y + 5\n\n        g.append('path')\n        .attr('class', 'bPath-'+node['regex']['key'])\n        .attr('d', function(){\n          var x0 = curX\n          var y0 = curY + 10\n          var x1 = curX + 20\n          var y1 = curY\n          var x2 = curX + 40\n          var y2 = curY + 10\n\n          return \"M \" +  x0 + \" \" +  y0 +\n                \" L \" + x1+ \" \" + y1 + \n                \" L \" + x2+ \" \" + y2\n        })\n        .attr('style','stroke: #c4bbbb; stroke-width: 2px; fill: none;')\n\n\n        g.append('text')\n          .attr('x', curX+1)\n          .attr('y', curY-4)\n          .attr('font-size', '14px')\n          .attr('alignment-baseline', 'hanging')\n          .attr('text-anchor', 'middle')\n          .attr('font-weight', 'bold')\n          .attr('fill', '#2c2c2c')\n          .text(() => node['regex']['repeat'][0])\n        \n        if(node['regex']['repeat'][1] == '*'){\n          g.append('text')\n            .attr('x', curX+38)\n            .attr('y', curY-2)\n            .attr('font-size', '18px')\n            .attr('alignment-baseline', 'hanging')\n            .attr('text-anchor', 'middle')\n            .attr('font-weight', 'bold')\n            .attr('fill', '#2c2c2c')\n            .text(() => node['regex']['repeat'][1])\n        }\n        else{\n          g.append('text')\n          .attr('x', curX+38)\n          .attr('y', curY-4)\n          .attr('font-size', '14px')\n          .attr('alignment-baseline', 'hanging')\n          .attr('text-anchor', 'middle')\n          .attr('font-weight', 'bold')\n          .attr('fill', '#2c2c2c')\n          .text(() => node['regex']['repeat'][1])\n        }\n\n\n\n        g.append('rect')\n          .attr('width', '40')\n          .attr('height', '10')\n          .attr('transform', function(){\n          var x = curX\n          var y = curY\n          return `translate(${x}, ${y})`\n          })\n          .attr('opacity', '0')\n          .on('click', function(){\n            that.UPDATE_SELECTED_DOM(node['regex'])\n              d3.selectAll('.bPath-'+node['regex']['key'])\n                .attr('style', 'stroke: red; stroke-width: 2px; fill: none;')\n              })\n\n        curY += 15\n        eleHeight += 15\n\n\n        \n        for(let i in node['regex']['composition']){\n          if(node['regex']['composition'][i]['type'] == 'node'){\n            if('notFlag' in node['regex']['composition'][i] && node['regex']['composition'][i]['notFlag']){\n              g.append('path')\n                .attr('d', function(){\n                  var x1 = curX-3\n                  var y1 = curY+5\n              \n                  return ( \"M \" + x1 + \" \" + y1 +\n                          \"v \" + 23);\n                })\n              .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n              g.append('circle')\n              .attr('cx', curX-3)\n              .attr('cy', curY+33)\n              .attr('r', '0.7')\n              .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n            \n            }\n\n            g.append('rect')\n              .attr('class', 'unselectable title')\n              .attr('id', 'rect'+node['regex']['composition'][i]['key'])\n              .attr('x', curX)\n              .attr('y', curY)\n              .attr('width', 40)\n              .attr('height', 40)\n              .attr('style', function(){\n                  let tmpKey = sysDatasetObj.getSelectedDomKey()\n                    if(node['regex']['composition'][i]['key'] === tmpKey){\n                        return ( \n                                \"stroke: red !important;\" + \n                                \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                                \"stroke-dasharray: 0 0; \" + \n                                \"stroke-width: 1;\"\n                        )\n                    }\n                    return (\n                      \"stroke: #c4bbbb; !important;\" + \n                      \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \" + \n                        \"stroke-dasharray: 0 0; \" + \n                        \"stroke-width: 1;\"\n                    )\n                  if('definition' in node['regex']['composition'][i]){\n                      if(node['regex']['composition'][i]['definition']){\n                          if(node['regex']['composition'][i]['key'] === tmpKey){\n                              return ( \n                                      \"stroke: red !important;\" + \n                                      \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                                      \"stroke-dasharray: 0 0; \" + \n                                      \"stroke-width: 1;\"\n                              )\n                          }\n                          return (\n                            \"stroke: #c4bbbb; !important;\" + \n                            \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \" + \n                              \"stroke-dasharray: 0 0; \" + \n                              \"stroke-width: 1;\"\n                          )\n\n                      }\n                  }\n                  if('key' in node['regex']['composition'][i] && node['regex']['composition'][i].key === tmpKey){\n                        return ( \"stroke: red !important; \"+                \n                          \"stroke-width: 2; \" + \n                          \"stroke-dasharray: 4 2;\" + \n                          \"fill: white; \");\n                  }\n                  return (\n                      \"stroke: #c4bbbb; \" + \n                      \"stroke-width: 2; \" + \n                      \"stroke-dasharray: 4 2;\" + \n                      \"fill: white; \"\n                  )\n              })\n              .on('click', function(){\n                d3.select(this)\n                .attr('style', function(){\n                                            return (     \n                            \"stroke: red !important;\" + \n                            \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                            \"stroke-dasharray: 0 0; \" + \n                            \"stroke-width: 1;\"\n                          )\n                    if('definition' in node['regex']['composition'][i]){\n                        if(node['regex']['composition'][i]['definition']){\n                          return (     \n                            \"stroke: red !important;\" + \n                            \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                            \"stroke-dasharray: 0 0; \" + \n                            \"stroke-width: 1;\"\n                          )\n                        }\n                    }\n                    return (\n                          \"stroke: red !important;\" + \n                          \"stroke-width: 2; \" + \n                          \"stroke-dasharray: 4 2;\" + \n                          \"fill: white; \"\n                      )\n                })\n                that.UPDATE_CONDITION_STATE(false)\n                that.UPDATE_SELECTED_DOM(node['regex']['composition'][i])\n                sysDatasetObj.updateSelectedBranch(node['regex'], i)\n                sysDatasetObj.updateSelectedOr(node['regex']['composition'][i], -1)\n              })\n            if('nodeName' in node['regex']['composition'][i]){\n              if(node['regex']['composition'][i]['nodeName'] == '.'){\n                g.append('text')\n                .attr('class', 'new11')\n                .attr('x', curX + 20)\n                .attr('y', curY + 12)\n                .attr('fill', 'white')\n                .attr('font-size', '50px')\n                .attr('text-anchor', \"middle\")\n                .attr(\"alignment-baseline\", \"middle\")\n                .attr('class', 'unselectable title')\n                .text(() => node['regex']['composition'][i]['nodeName'])\n                .on('click', function(){\n                    d3.select('#rect'+node['regex']['composition'][i]['key'])\n                    .attr('style', function(){\n                                          return (     \n                            \"stroke: red !important;\" + \n                            \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                            \"stroke-dasharray: 0 0; \" + \n                            \"stroke-width: 1;\"\n                          )\n                })\n                  that.UPDATE_CONDITION_STATE(false)\n                  that.UPDATE_SELECTED_DOM(node['regex']['composition'][i])\n                  sysDatasetObj.updateSelectedBranch(node['regex'], i)\n                  sysDatasetObj.updateSelectedOr(node['regex']['composition'][i], -1)\n                })\n              }\n              else{\n                g.append('text')\n                .attr('class', 'new11')\n                .attr('x', curX + 20)\n                .attr('y', curY + 20 + 2.5)\n                .attr('fill', 'white')\n                .attr('font-size', '20px')\n                .attr('text-anchor', \"middle\")\n                .attr(\"alignment-baseline\", \"middle\")\n                .attr('class', 'unselectable title')\n                .text(() => node['regex']['composition'][i]['nodeName'])\n                .on('click', function(){\n                    d3.select('#rect'+node['regex']['composition'][i]['key'])\n                    .attr('style', function(){\n                                          return (     \n                            \"stroke: red !important;\" + \n                            \"fill: \" + node['regex']['composition'][i]['nodeColor'] + \"; \"+\n                            \"stroke-dasharray: 0 0; \" + \n                            \"stroke-width: 1;\"\n                          )\n                })\n                  that.UPDATE_CONDITION_STATE(false)\n                  that.UPDATE_SELECTED_DOM(node['regex']['composition'][i])\n                  sysDatasetObj.updateSelectedBranch(node['regex'], i)\n                  sysDatasetObj.updateSelectedOr(node['regex']['composition'][i], -1)\n                })\n              }\n            }\n\n\n            if(!(node['regex']['composition'][i]['repeat'][0] == 1 && node['regex']['composition'][i]['repeat'][1] == 1)){\n              g.append('path')\n              .attr('class', '1bPath-'+node['regex']['key'])\n              .attr('d', function(){\n                var x1 = curX + 40 + 3;\n                var y1 = curY + 16;\n                var x2 = curX + 40 + 3;\n                var y2 = curY + 24;\n                var r = 7;\n                eleWidth = 5 + 15;\n                return 'M ' + x1 + ',' + y1 + ' ' + 'A ' + r + ',' + r + ' ' + '0 ' + '1,1' + ' ' + x2 + ',' + y2;\n              })\n              .attr('style','stroke: #000000; stroke-width: 1.5px; fill: none;')\n\n              g.append('path')\n              .attr('class', '1bPath-'+node['regex']['key'])\n              .attr('d', function(){\n                var x0 = curX + 40 + 3\n                var y0 = curY + 24\n                var x1 = x0 + 4\n                var y1 = y0 + 6\n\n                return \"M \" +  x1 + \",\" +  y1 +\n                  \" L \" + x0 + \",\" + y0 ;\n              })\n              .attr('style','stroke: #000000; stroke-width: 1.5px; fill: none;')\n\n              g.append('text')\n              .attr('x', curX + 40 + 5)\n              .attr('y', curY )\n              .attr('font-size', '12px')\n              .attr('alignment-baseline', 'hanging')\n              .attr('font-weight', 'bold')\n            .attr('fill', '#2c2c2c')\n              .text(() => node['regex']['composition'][i]['repeat'][0])\n\n              if(node['regex']['composition'][i]['repeat'][1] == '*'){\n                g.append('text')\n                  .attr('x', curX + 40 + 5)\n                  .attr('y', curY + 30)\n                  .attr('font-size', '20px')\n                  .attr('alignment-baseline', 'hanging')\n                  .attr('font-weight', 'bold')\n                  .attr('fill', '#2c2c2c')\n                  .text(() => node['regex']['composition'][i]['repeat'][1])\n              }\n              else{\n                g.append('text')\n                .attr('x', curX + 40 + 5)\n                .attr('y', curY + 30)\n                .attr('font-size', '12px')\n                .attr('alignment-baseline', 'hanging')\n                .attr('font-weight', 'bold')\n                .attr('fill', '#2c2c2c')\n                .text(() => node['regex']['composition'][i]['repeat'][1])\n              }\n            }\n\n            curY = curY + 40 + 10\n            eleHeight = eleHeight + 40 + 10\n\n\n          }\n          else if(node['regex']['composition'][i]['type'] == 'or'){\n            g.append('path')\n            .attr('class', 'path-'+node['regex']['composition'][i]['key'])\n            .attr('d', function(){\n              var x1 = curX + 15\n              var y1 = curY + 2.5\n              var x2 = curX + 15\n              var y2 = curY + 44.5\n\n              var qx = x1-(y2-y1)/3\n              var qy = (y2+y1)/2\n\n              return ( \"M \" +  x1 + \" \" +  y1 +\n                    \" Q \" + qx + \" \" + qy + \" \" + x2 + \" \" + y2 );\n            })\n            .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n\n            g.append('rect')\n              .attr('width', '18')\n              .attr('height', '42')\n              .attr('transform', function(){\n                var x1 = curX + 15\n                var y1 = curY + 2.5\n                var x2 = curX + 15\n                var y2 = curY + 44.5\n\n                var qx = x1-(y2-y1)/3 + 5\n                var qy = (y2+y1)/2\n                return `translate(${qx}, ${y1})`\n              })\n              .attr('opacity', '0')\n              .on('click', function(){\n                that.UPDATE_SELECTED_DOM(node['regex']['composition'][i])\n                  d3.selectAll('.path-'+node['regex']['composition'][i]['key'])\n                    .attr('style', 'stroke: red; stroke-width: 2px; fill: none;')\n                  })\n\n            curX = curX + 15\n            eleWidth += 15\n\n            for(let j in node['regex']['composition'][i]['composition']){\n              if(j!=0){\n                g.append('path')\n                .attr('d', function(){\n                  var x1 = curX+10\n                  var y1 = curY+3\n                  return ( \"M \" +  x1 + \" \" +  y1 +\n                      \" v \" + 42);\n                })\n                .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n                curX += 10\n                eleWidth += 5\n              }\n              \n              if('notFlag' in node['regex']['composition'][i]['composition'][j] && node['regex']['composition'][i]['composition'][j]['notFlag']){\n              g.append('path')\n              .attr('d', function(){\n                var x1 = curX+7\n                var y1 = curY+5\n            \n                return ( \"M \" + x1 + \" \" + y1 +\n                        \"v \" + 32);\n              })\n              .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n              g.append('circle')\n              .attr('cx', curX+7)\n              .attr('cy', curY+40)\n              .attr('r', '1')\n              .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n            \n              curX += 3\n              eleWidth += 3\n            }\n\n                g.append('rect')\n                  .attr('class', 'unselectable title')\n                  .attr('id', 'rect'+node['regex']['composition'][i]['composition'][j]['key'])\n                  .attr('x', curX+10)\n                  .attr('y', curY+3)\n                  .attr('width', 42)\n                  .attr('height', 42)\n                  .attr('style', function(){\n                      let tmpKey = sysDatasetObj.getSelectedDomKey()\n                      if('definition' in node['regex']['composition'][i]['composition'][j]){\n                          if(node['regex']['composition'][i]['composition'][j]['definition']){\n                              if(node['regex']['composition'][i]['composition'][j]['key'] === tmpKey){\n                                  return ( \n                                          \"stroke: red !important;\" + \n                                          \"fill: \" + node['regex']['composition'][i]['composition'][j]['nodeColor'] + \"; \"+\n                                          \"stroke-dasharray: 0 0; \" + \n                                          \"stroke-width: 1;\"\n                                  )\n                              }\n                              return (\n                                \"stroke: #c4bbbb; !important;\" + \n                                \"fill: \" + node['regex']['composition'][i]['composition'][j]['nodeColor'] + \"; \" + \n                                  \"stroke-dasharray: 0 0; \" + \n                                  \"stroke-width: 1;\"\n                              )\n\n                          }\n                      }\n                      if('key' in node['regex']['composition'][i]['composition'][j] && node['regex']['composition'][i]['composition'][j].key === tmpKey){\n                            return ( \"stroke: red !important; \"+                \n                              \"stroke-width: 2; \" + \n                              \"stroke-dasharray: 4 2;\" + \n                              \"fill: white; \");\n                      }\n                      return (\n                          \"stroke: #c4bbbb; \" + \n                          \"stroke-width: 2; \" + \n                          \"stroke-dasharray: 4 2;\" + \n                          \"fill: white; \"\n                      )\n                  })\n                  .on('click', function(){\n                    d3.select(this)\n                    .attr('style', function(){\n                        if('definition' in node['regex']['composition'][i]['composition'][j]){\n                            if(node['regex']['composition'][i]['composition'][j]['definition']){\n                              return (     \n                                \"stroke: red !important;\" + \n                                \"fill: \" + node['regex']['composition'][i]['composition'][j]['nodeColor'] + \"; \"+\n                                \"stroke-dasharray: 0 0; \" + \n                                \"stroke-width: 1;\"\n                              )\n                            }\n                        }\n                        return (\n                              \"stroke: red !important;\" + \n                              \"stroke-width: 2; \" + \n                              \"stroke-dasharray: 4 2;\" + \n                              \"fill: white; \"\n                          )\n                    })\n                    that.UPDATE_CONDITION_STATE(false)\n                    that.UPDATE_SELECTED_DOM(node['regex']['composition'][i]['composition'][j])\n                    sysDatasetObj.updateSelectedOr(node['regex']['composition'][i], j)\n                  })\n                if('nodeName' in node['regex']['composition'][i]['composition'][j]){\n                  g.append('text')\n                  .attr('class', 'new11')\n                  .attr('x', curX + 31)\n                  .attr('y', curY + 24)\n                  .attr('fill', 'white')\n                  .attr('font-size', '18px !important')\n                  .attr('text-anchor', \"middle\")\n                  .attr(\"alignment-baseline\", \"middle\")\n                  .attr('class', 'unselectable title')\n                  .text(() =>node['regex']['composition'][i]['composition'][j]['nodeName'])\n                  .on('click', function(){\n                      d3.select('#rect'+node['regex']['composition'][i]['key'])\n                      .attr('style', function(){\n                      if('definition' in node['regex']['composition'][i]['composition'][j]){\n                          if(node['regex']['composition'][i]['composition'][j]['definition']){\n                            return (     \n                              \"stroke: red !important;\" + \n                              \"fill: \" + node['regex']['composition'][i]['composition'][j]['nodeColor'] + \"; \"+\n                              \"stroke-dasharray: 0 0; \" + \n                              \"stroke-width: 1;\"\n                            )\n                          }\n                      }\n                      return (\n                          \"stroke: red !important;\" + \n                          \"stroke-width: 2; \" + \n                          \"stroke-dasharray: 4 2;\" + \n                          \"fill: white; \"\n                      )\n                  })\n                    that.UPDATE_CONDITION_STATE(false)\n                    that.UPDATE_SELECTED_DOM(node['regex']['composition'][i]['composition'][j])\n                    sysDatasetObj.updateSelectedOr(node['regex']['composition'][i], j)\n                  })\n                }\n                curX = curX + 52\n                eleWidth += 52\n                if(!(node['regex']['composition'][i]['composition'][j]['repeat'][0] == 1 && node['regex']['composition'][i]['composition'][j]['repeat'][1] == 1)){\n                  g.append('text')\n                  .attr('x', curX + 5)\n                  .attr('y', curY + 2)\n                  .attr('font-size', '15px')\n                  .attr('alignment-baseline', 'hanging')\n                  .text(() => node['regex']['composition'][i]['composition'][j]['repeat'][0] + '..' + node['regex']['composition'][i]['composition'][j]['repeat'][1])\n                  curX = curX + 30\n                  eleWidth += 30\n                }\n            }\n            g.append('path')\n              .attr('class', 'path-'+node['regex']['composition'][i]['key'])\n              .attr('d', function(){\n                var x1 = curX + 10\n                var y1 = curY + 2.5\n                var x2 = curX + 10\n                var y2 = curY + 44.5\n\n                var qx = x1+(y2-y1)/3\n                var qy = (y2+y1)/2\n\n                return ( \"M \" +  x1 + \" \" +  y1 +\n                      \" Q \" + qx + \" \" + qy + \" \" + x2 + \" \" + y2 );\n              })\n              .attr('style','stroke: #000000; stroke-width: 2px; fill: none;')\n\n              g.append('rect')\n                .attr('width', '18')\n                .attr('height', '42')\n                .attr('transform', function(){\n                  var x1 = curX + 10\n                  var y1 = curY + 2.5\n                  var x2 = curX + 10\n                  var y2 = curY + 44.5\n\n                  var qx = x1-5\n                  var qy = (y2+y1)/2\n                  return `translate(${qx}, ${y1})`\n                })\n              .attr('opacity', '0')\n              .on('click', function(){\n                that.UPDATE_SELECTED_DOM(node['regex']['composition'][i])\n                  d3.selectAll('.path-'+node['regex']['composition'][i]['key'])\n                    .attr('style', 'stroke: red; stroke-width: 2px; fill: none;')\n                  })\n\n              curX = curX + 15\n              eleWidth += 15\n\n            if(!(node['regex']['composition'][i]['repeat'][0] == 1 && node['regex']['composition'][i]['repeat'][1] == 1)){\n              g.append('text')\n              .attr('x', curX + 5)\n              .attr('y', curY + 2)\n              .attr('font-size', '15px')\n              .attr('alignment-baseline', 'hanging')\n              .text(() => node['regex']['composition'][i]['repeat'][0] + '..' + node['regex']['composition'][i]['repeat'][1])\n              curX = curX + 30\n              eleWidth += 30\n            }\n\n            node.width = 8 + eleWidth\n\n          }\n\n        }\n        \n        node.width = eleWidth + 40 + 5\n        node.height = eleHeight - 5\n\n\n        \n      }\n\n\n          // .attr(\"class\", \"connector\");\n      let connectors = [];\n      let connectorPosition = this.getConnectorPosition(node);\n      for (let position in connectorPosition) {\n        let positionElement = connectorPosition[position];\n        let connector = g\n          .append(\"circle\")\n          .attr(\"cx\", positionElement.x)\n          .attr(\"cy\", positionElement.y)\n          .attr(\"r\", 4)\n          .attr(\"class\", \"connector\");\n\n        connector\n          .on(\"mousedown\", function () {\n            d3.event.stopPropagation();\n            if (node.type === \"end\" || that.readonly) {\n              return;\n            }\n            that.connectingInfo.source = node;\n            that.connectingInfo.sourcePosition = position;\n          })\n          .on(\"mouseup\", function () {\n            d3.event.stopPropagation();\n            if (that.connectingInfo.source) {\n              if (that.connectingInfo.source.id !== node.id) {\n                // Node can't connect to itself\n                let tempId = +new Date();\n                let conn = {\n                  source: {\n                    id: that.connectingInfo.source.id,\n                    position: that.connectingInfo.sourcePosition,\n                  },\n                  destination: {\n                    id: node.id,\n                    position: position,\n                  },\n                  id: tempId,\n                  type: \"pass\",\n                  name: \"Pass\",\n                };\n                let tmpSource = that.internalNodes.filter((item) => item.id === conn['source']['id'])[0]\n                let tmpDestination = that.internalNodes.filter((item) => item.id === conn['destination']['id'])[0]\n                sysDatasetObj.addEdge(tmpSource['regexIndex'], tmpDestination['regexIndex'])\n                that.internalConnections.push(conn);\n\n              }\n              that.connectingInfo.source = null;\n              that.connectingInfo.sourcePosition = null;\n            }\n          })\n          .on(\"mouseover\", function () {\n            connector.classed(\"active\", true);\n          })\n          .on(\"mouseout\", function () {\n            connector.classed(\"active\", false);\n          });\n        connectors.push(connector);\n      }\n      g.on(\"mouseover\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", true));\n      }).on(\"mouseout\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", false));\n      });\n    },\n    getCurrentNodesEdge() {\n      let points = this.currentNodes.map((node) => ({\n        x: node.x,\n        y: node.y,\n      }));\n      points.push(\n        ...this.currentNodes.map((node) => ({\n          x: node.x + node.width,\n          y: node.y + node.height,\n        }))\n      );\n      return getEdgeOfPoints(points);\n    },\n    async remove() {\n      if (this.readonly) {\n        return;\n      }\n      if (this.currentConnections.length > 0) {\n        for (let conn of this.currentConnections) {\n          this.removeConnection(conn);\n        }\n        this.currentConnections.splice(0, this.currentConnections.length);\n      }\n      if (this.currentNodes.length > 0) {\n        for (let node of this.currentNodes) {\n          this.removeNode(node);\n        }\n        this.currentNodes.splice(0, this.currentNodes.length);\n      }\n    },\n    removeNode(node) {\n      let connections = this.internalConnections.filter(\n        (item) => item.source.id === node.id || item.destination.id === node.id\n      );\n      for (let connection of connections) {\n        this.internalConnections.splice(\n          this.internalConnections.indexOf(connection),\n          1\n        );\n      }\n      sysDatasetObj.deleteEdge(node['regexIndex'])\n      this.internalNodes.splice(this.internalNodes.indexOf(node), 1);\n    },\n    removeConnection(conn) {\n      let index = this.internalConnections.indexOf(conn);\n      let tmpSource = this.internalNodes.filter((item) => item.id === conn['source']['id'])[0]\n      let tmpDestination = this.internalNodes.filter((item) => item.id === conn['destination']['id'])[0]\n      sysDatasetObj.deleteEdge1(tmpSource['regexIndex'], tmpDestination['regexIndex'])\n      this.internalConnections.splice(index, 1);\n    },\n    moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        for (let node of this.currentNodes) {\n          node.x += x;\n          node.y += y;\n        }\n      }\n    },\n    init() {\n      let that = this;\n      that.internalNodes.splice(0, that.internalNodes.length);\n      that.internalConnections.splice(0, that.internalConnections.length);\n      that.nodes.forEach((node) => {\n        let newNode = Object.assign({}, node);\n        newNode.width = newNode.width || 120;\n        newNode.height = newNode.height || 60;\n        that.internalNodes.push(newNode);\n      });\n      that.connections.forEach((connection) => {\n        that.internalConnections.push(JSON.parse(JSON.stringify(connection)));\n      });\n    },\n    ...mapMutations([\n      'UPDATE_HOVERING_ID'\n    ])\n  },\n  mounted() {\n    let that = this;\n    that.init();\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.push(...that.internalNodes);\n            that.currentConnections.push(...that.internalConnections);\n            event.preventDefault();\n          }\n          break;\n        // delete the selected item\n        case 8:\n        // case 46:\n        //   that.remove();\n        //   break;\n        default:\n          break;\n      }\n    };\n  },\n  created() {},\n  computed: {\n    // ...mapState([\n    //   'hoveringId'\n    // ]),\n    hoveredConnector() {\n      for (const node of this.internalNodes) {\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let prop in connectorPosition) {\n          let entry = connectorPosition[prop];\n          if (\n            Math.hypot(\n              entry.x - this.cursorToChartOffset.x,\n              entry.y - this.cursorToChartOffset.y\n            ) < 10\n          ) {\n            return { position: prop, node: node };\n          }\n        }\n      }\n      return null;\n    },\n    hoveredConnection() {\n      for (const line of this.lines) {\n        let distance = distanceOfPointToLine(\n          line.sourceX,\n          line.sourceY,\n          line.destinationX,\n          line.destinationY,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y\n        );\n        if (\n          distance < 5 &&\n          between(\n            line.sourceX - 2,\n            line.destinationX + 2,\n            this.cursorToChartOffset.x\n          ) &&\n          between(\n            line.sourceY - 2,\n            line.destinationY + 2,\n            this.cursorToChartOffset.y\n          )\n        ) {\n          let connections = this.internalConnections.filter(\n            (item) => item.id === line.id\n          );\n          return connections.length > 0 ? connections[0] : null;\n        }\n      }\n      return null;\n    },\n    cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n      return null;\n    },\n  },\n  watch: {\n\n    internalNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n        this.renderConnections();\n      },\n    },\n    internalConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderSelection();\n      },\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n      },\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      },\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.init();\n      },\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.init();\n      },\n    },\n  },\n};\n</script>\n<style lang=\"less\" scoped>\n.query-btn{\n    position: absolute;\n    left: 5px;\n    bottom: 5px;\n    font-size: 0.8rem;\n    font-weight: bolder;\n    color: #808080;\n    line-height: 10px;\n    // background: #fff;\n    // border: 1px solid #dcdfe6;\n    // cursor: pointer;\n    // border-radius: 4px;\n    // &.selected {\n    // color: #409eff;\n    // border-color: #c6e2ff;\n    // background-color: #ecf5ff;\n    // }\n    //  &.hover {\n    // color: #409eff;\n    // border-color: #c6e2ff;\n    // background-color: #ecf5ff;\n    // }\n  \n}\npath {\n    &.highlighted {\n        stroke: red;\n    }\n}\n\n</style>\n"]}]}