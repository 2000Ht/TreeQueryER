{"remainingRequest":"/Users/ht.mi/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ht.mi/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/src/components/CirclePacking.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ht.mi/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/src/components/CirclePacking.vue","mtime":1648714649000},{"path":"/Users/ht.mi/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":1660192275271},{"path":"/Users/ht.mi/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/babel-loader/lib/index.js","mtime":1660192275351},{"path":"/Users/ht.mi/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":1660192275271},{"path":"/Users/ht.mi/研究生资料/个人论文/tree_visual_query/RETree-main/FrontEnd/node_modules/vue-loader/lib/index.js","mtime":1660192275522}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n\nimport { mapState, mapMutations } from 'vuex';\nimport golbalVariable from '../global'\nimport recursive from '../recursive'\nexport default {\n  name: 'CirclePacking',\n  props: {\n    msg: String,\n    width: Number,\n    height: Number,\n    jsonpath: String,\n    jsondata: Object,\n    random_highlight: Object,\n  },\n  watch: {\n      width: function() {\n        this.draw_circle_packing(this.jsonpath, this.jsondata, this.width, this.height, 0);\n      },\n      height: function() {\n        this.draw_circle_packing(this.jsonpath, this.jsondata, this.width, this.height, 0);\n      },\n      treeViewState: function(){\n        this.draw_circle_packing(this.jsonpath, this.jsondata, this.width, this.height, 0);\n      }\n  },\n  computed: {\n    ...mapState([\n      'treeViewState'\n    ])\n  },\n  data(){\n    return{\n      counter: 0,\n      scale: 400,\n    }\n  },\n  mounted() {\n    this.draw_circle_packing(this.jsonpath, this.jsondata, this.width, this.height, 0);\n  },\n  methods:{\n    draw_circle_packing: function(jsonpath, jsondata, width, height, needlable=false) {\n      \n      d3.select('#circle_packing').selectAll('*').remove();\n\n      let data = JSON.parse(JSON.stringify(jsondata))\n\n      data = this.recursive(data)\n\n      let keep_random_highlight = []\n      if(this.random_highlight != null){\n        let namelist = d3.hierarchy(data).descendants().map(d=>d.data.name)\n        if(golbalVariable.highlight_2leaves){namelist = d3.hierarchy(data).leaves().map(d=>d.data.name)}\n        for(let k=0;k<Object.keys(this.random_highlight).length;k++)\n        {\n          let randomValue = this.random_highlight[Object.keys(this.random_highlight)[k]]\n          keep_random_highlight.push(\".\"+namelist[Math.floor(randomValue * (namelist.length - 1))]+\"cpk\")\n        }\n      }\n\n      // d3.json(jsonpath)\n      //   .then( (data) =>{\n\n          let min_width_height = Math.min(width, height);\n          // let font_size_r = (min_width_height * 8) / this.scale;\n          let padding_r = (min_width_height *3) / this.scale;\n          let r_r = (min_width_height *10) / this.scale;\n\n          let trbl = (min_width_height * 20) / this.scale;\n          let margin = { top: trbl, right: trbl, bottom: trbl, left: trbl };\n          let innerWidth = width - margin.left;\n          let innerHeight = height - margin.top;\n\n          const svg = d3.select(this.$el)\n            .select('#circle_packing')\n            .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\")\n            .attr(\"font-family\", \"sans-serif\")\n\n          const g = svg.append('g')\n            .attr('transform', `translate(${margin.left/2}, ${margin.top/2})`);\n\n          g.append('style').text(`\n            .rect-cpk-active {\n              stroke: steelblue !important;\n              stroke-opacity: 1;\n              stroke-width: 1.5px;\n            }\n            .highlight-cpk-active {\n              stroke: steelblue;\n              stroke-opacity: 1;\n              stroke-width: 1.5px;\n            }\n          `);\n\n          let root = d3.hierarchy(data)\n            .sum(d=>d.value)\n            .sort((a,b)=>b.value - a.value);\n          \n          root = d3.pack()\n            .size([innerWidth, innerHeight])\n            .padding(padding_r) (root);\n\n          let leaves = root.descendants().filter(d=>!d.children);\n          leaves.forEach((d,i)=>d.index = i);\n\n          let title = function(n){return `PATH: ${n.ancestors().reverse().map(d => d.data.name).join(\".\")}\\nNAME: ${n.data.name}\\nVALUE: ${n.value.toLocaleString(\"en\")}`; };\n          let label = function(d,n){return [...d.name.split(/(?=[A-Z][a-z])/g), n.value.toLocaleString(\"en\")].join(\"\\n\"); }\n\n          let L = leaves.map(d=> label(d.data, d));\n\n          let node = g.selectAll('a')\n            .data(root.descendants())\n            .join('a')\n              .attr('transform', d=>`translate(${d.x},${d.y})`);\n\n          node.append('circle')\n            .attr('class',d=>d.data.name+'cpk')\n            .attr('fill', d=>d.children ? '#fff' : '#ddd')\n            .attr('stroke', d=>d.children ? '#bbb' : null)\n            .attr('r', d=>d.r)\n            .on(\"mouseover\", mouseovered(true, keep_random_highlight))\n            .on(\"mouseout\", mouseovered(false, keep_random_highlight));\n          \n\n          if(title!=null) node.append('title').text(d=>title(d));\n\n          if(L && needlable){\n            let uid = `O-${Math.random().toString(16).slice(2)}`;\n\n            let leaf = node.filter(d=>!d.children && d.r > r_r && L[d.index] != null);\n\n            leaf.append('clipPath')\n              .attr('id', d=>`${uid}-clip-${d.index}`)\n            .append('circle')\n              .attr('r', d=>d.r);\n\n            leaf.append(\"text\")\n              .attr(\"clip-path\", d => `url(${new URL(`#${uid}-clip-${d.index}`, location)})`)\n            .selectAll(\"tspan\")\n            .data(d => `${L[d.index]}`.split(/\\n/g))\n            .join(\"tspan\")\n              .attr(\"x\", 0)\n              .attr(\"y\", (d, i, D) => `${(i - D.length / 2) + 0.85}em`)\n              .attr(\"fill-opacity\", (d, i, D) => i === D.length - 1 ? 0.7 : null)\n              .text(d => d);\n          }\n\n          function mouseovered(active, keep_random_highlight){\n\n            for(let k=0;k<keep_random_highlight.length;k++){\n              d3.select(keep_random_highlight[k]).classed(\"highlight-cpk-active\", true);\n            }\n            return function(d, i){\n              d3.select(this).classed(\"rect-cpk-active\", active);\n              for(let j=0; j< Object.values(d.ancestors().map(d=>\".\"+d.data.name)).length; j++){\n                d3.select(Object.values(d.ancestors().map(d=>\".\"+d.data.name+\"cpk\"))[j]).classed(\"rect-cpk-active\", active);                \n              }\n            }\n          }\n        \n      // });\n\n    }\n  }\n}\n",{"version":3,"sources":["CirclePacking.vue"],"names":[],"mappings":";;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA","file":"CirclePacking.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"canvas\">\n    <svg id=\"circle_packing\" :width=\"width\" :height=\"height\"></svg>\n  </div>\n</template>\n\n<script>\nimport { mapState, mapMutations } from 'vuex';\nimport golbalVariable from '../global'\nimport recursive from '../recursive'\nexport default {\n  name: 'CirclePacking',\n  props: {\n    msg: String,\n    width: Number,\n    height: Number,\n    jsonpath: String,\n    jsondata: Object,\n    random_highlight: Object,\n  },\n  watch: {\n      width: function() {\n        this.draw_circle_packing(this.jsonpath, this.jsondata, this.width, this.height, 0);\n      },\n      height: function() {\n        this.draw_circle_packing(this.jsonpath, this.jsondata, this.width, this.height, 0);\n      },\n      treeViewState: function(){\n        this.draw_circle_packing(this.jsonpath, this.jsondata, this.width, this.height, 0);\n      }\n  },\n  computed: {\n    ...mapState([\n      'treeViewState'\n    ])\n  },\n  data(){\n    return{\n      counter: 0,\n      scale: 400,\n    }\n  },\n  mounted() {\n    this.draw_circle_packing(this.jsonpath, this.jsondata, this.width, this.height, 0);\n  },\n  methods:{\n    draw_circle_packing: function(jsonpath, jsondata, width, height, needlable=false) {\n      \n      d3.select('#circle_packing').selectAll('*').remove();\n\n      let data = JSON.parse(JSON.stringify(jsondata))\n\n      data = this.recursive(data)\n\n      let keep_random_highlight = []\n      if(this.random_highlight != null){\n        let namelist = d3.hierarchy(data).descendants().map(d=>d.data.name)\n        if(golbalVariable.highlight_2leaves){namelist = d3.hierarchy(data).leaves().map(d=>d.data.name)}\n        for(let k=0;k<Object.keys(this.random_highlight).length;k++)\n        {\n          let randomValue = this.random_highlight[Object.keys(this.random_highlight)[k]]\n          keep_random_highlight.push(\".\"+namelist[Math.floor(randomValue * (namelist.length - 1))]+\"cpk\")\n        }\n      }\n\n      // d3.json(jsonpath)\n      //   .then( (data) =>{\n\n          let min_width_height = Math.min(width, height);\n          // let font_size_r = (min_width_height * 8) / this.scale;\n          let padding_r = (min_width_height *3) / this.scale;\n          let r_r = (min_width_height *10) / this.scale;\n\n          let trbl = (min_width_height * 20) / this.scale;\n          let margin = { top: trbl, right: trbl, bottom: trbl, left: trbl };\n          let innerWidth = width - margin.left;\n          let innerHeight = height - margin.top;\n\n          const svg = d3.select(this.$el)\n            .select('#circle_packing')\n            .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\")\n            .attr(\"font-family\", \"sans-serif\")\n\n          const g = svg.append('g')\n            .attr('transform', `translate(${margin.left/2}, ${margin.top/2})`);\n\n          g.append('style').text(`\n            .rect-cpk-active {\n              stroke: steelblue !important;\n              stroke-opacity: 1;\n              stroke-width: 1.5px;\n            }\n            .highlight-cpk-active {\n              stroke: steelblue;\n              stroke-opacity: 1;\n              stroke-width: 1.5px;\n            }\n          `);\n\n          let root = d3.hierarchy(data)\n            .sum(d=>d.value)\n            .sort((a,b)=>b.value - a.value);\n          \n          root = d3.pack()\n            .size([innerWidth, innerHeight])\n            .padding(padding_r) (root);\n\n          let leaves = root.descendants().filter(d=>!d.children);\n          leaves.forEach((d,i)=>d.index = i);\n\n          let title = function(n){return `PATH: ${n.ancestors().reverse().map(d => d.data.name).join(\".\")}\\nNAME: ${n.data.name}\\nVALUE: ${n.value.toLocaleString(\"en\")}`; };\n          let label = function(d,n){return [...d.name.split(/(?=[A-Z][a-z])/g), n.value.toLocaleString(\"en\")].join(\"\\n\"); }\n\n          let L = leaves.map(d=> label(d.data, d));\n\n          let node = g.selectAll('a')\n            .data(root.descendants())\n            .join('a')\n              .attr('transform', d=>`translate(${d.x},${d.y})`);\n\n          node.append('circle')\n            .attr('class',d=>d.data.name+'cpk')\n            .attr('fill', d=>d.children ? '#fff' : '#ddd')\n            .attr('stroke', d=>d.children ? '#bbb' : null)\n            .attr('r', d=>d.r)\n            .on(\"mouseover\", mouseovered(true, keep_random_highlight))\n            .on(\"mouseout\", mouseovered(false, keep_random_highlight));\n          \n\n          if(title!=null) node.append('title').text(d=>title(d));\n\n          if(L && needlable){\n            let uid = `O-${Math.random().toString(16).slice(2)}`;\n\n            let leaf = node.filter(d=>!d.children && d.r > r_r && L[d.index] != null);\n\n            leaf.append('clipPath')\n              .attr('id', d=>`${uid}-clip-${d.index}`)\n            .append('circle')\n              .attr('r', d=>d.r);\n\n            leaf.append(\"text\")\n              .attr(\"clip-path\", d => `url(${new URL(`#${uid}-clip-${d.index}`, location)})`)\n            .selectAll(\"tspan\")\n            .data(d => `${L[d.index]}`.split(/\\n/g))\n            .join(\"tspan\")\n              .attr(\"x\", 0)\n              .attr(\"y\", (d, i, D) => `${(i - D.length / 2) + 0.85}em`)\n              .attr(\"fill-opacity\", (d, i, D) => i === D.length - 1 ? 0.7 : null)\n              .text(d => d);\n          }\n\n          function mouseovered(active, keep_random_highlight){\n\n            for(let k=0;k<keep_random_highlight.length;k++){\n              d3.select(keep_random_highlight[k]).classed(\"highlight-cpk-active\", true);\n            }\n            return function(d, i){\n              d3.select(this).classed(\"rect-cpk-active\", active);\n              for(let j=0; j< Object.values(d.ancestors().map(d=>\".\"+d.data.name)).length; j++){\n                d3.select(Object.values(d.ancestors().map(d=>\".\"+d.data.name+\"cpk\"))[j]).classed(\"rect-cpk-active\", active);                \n              }\n            }\n          }\n        \n      // });\n\n    }\n  }\n}\n</script>"]}]}