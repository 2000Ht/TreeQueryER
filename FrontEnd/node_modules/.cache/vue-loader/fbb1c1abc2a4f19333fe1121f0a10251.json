{"remainingRequest":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ht.mi/Downloads/RETree-main/FrontEnd/src/components/IndentedPixelTreePlots.vue?vue&type=style&index=0&id=4289c3a9&scoped=true&lang=less&","dependencies":[{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/src/components/IndentedPixelTreePlots.vue","mtime":1648714649000},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/css-loader/index.js","mtime":1660192274937},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1660192275629},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/postcss-loader/src/index.js","mtime":1660192275315},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/less-loader/dist/cjs.js","mtime":1660192275256},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":1660192275271},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/vue-loader/lib/index.js","mtime":1660192275522}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.canvas {\n  width: 100%;\n  height: 100%;\n  .inner-canvas {\n    width: 100%;\n    height: 100%;\n  }\n}\n",{"version":3,"sources":["IndentedPixelTreePlots.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"IndentedPixelTreePlots.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"canvas\" ref=\"canvas\">\n    <svg id=\"indentedpixeltreeplots\" class=\"inner-canvas\">\n      <g id=\"g-level-1\">\n        <g id=\"g-level-1-node\"></g>\n      </g>\n    </svg>\n  </div>\n</template>\n\n<script>\nimport { mapState, mapMutations } from 'vuex';\nimport bus from '../brushed'\nimport busInvert from '../brushedInvert'\nexport default {\n  name: 'IndentedPixelTreePlots',\n  props: {\n    dataBackGround: Object,\n    dataHighLight: Array,\n  },\n  watch: {\n      treeViewState: function() {\n        console.log(\"indentedpixeltreeplots dataBackGround\", this.dataBackGround)\n        console.log(\"indentedpixeltreeplots dataHighLight\", this.dataHighLight)\n        this.draw_indentedpixeltreeplots(this.dataBackGround, this.width, this.height, 0);\n        this.dataHighLight_In_and_Out('indentedpixeltreeplots', this.dataHighLight, bus, this.RootDes, 1)\n      },\n  },\n  computed: {\n    ...mapState([\n        'displayMode',\n        'treeViewState'\n      ])\n  },\n  data(){\n    return{\n      scale: 400,\n      brushed_data: null,\n      attr_ele_brushed_data: null,\n      RootDes: null,\n      json_data_out_node: null,\n      json_data_out_node_attr: null,\n      attr_ele_brushed_data_idList: [], //保存属性视图刷选的数据\n      hightLightType: null,\n    }\n  },\n  created() {\n    busInvert.$on('attr_ele_brushed_data', (data)=>{\n      this.attr_ele_brushed_data = data;\n      this.highlight_attr_ele_brushed_data()\n    })\n  },\n  mounted() {\n    this.width = this.$refs.canvas.clientWidth\n    this.height = this.$refs.canvas.clientHeight\n    console.log('width', this.width, 'height', this.height)\n    this.draw_indentedpixeltreeplots(this.dataBackGround, this.width, this.height, 0);\n    this.dataHighLight_In_and_Out('indentedpixeltreeplots', this.dataHighLight, bus, this.RootDes, 1)\n  },\n  methods:{\n    highlight_attr_ele_brushed_data: function() {\n      if(this.attr_ele_brushed_data == null || this.attr_ele_brushed_data == 'undefined'){\n        return;\n      }\n      else if(this.attr_ele_brushed_data.length > 0){\n        //treeIn 以及 treeOut 先变暗\n        this.dataHighLight_In_and_Out('indentedpixeltreeplots', this.dataHighLight, bus, this.RootDes, 0)\n        d3.select(this.$el).select('#indentedpixeltreeplots').selectAll('.tree-node').classed(this.hightLightType+'-highlight', false);\n        //将上一次属性视图需要高亮的节点变暗\n        this.attr_ele_brushed_data_idList.forEach(eleid=>{\n          d3.select(this.$el).select('#indentedpixeltreeplots')\n            .select('#node-id-' + eleid).classed(\"attr-brush-highlight\", false);\n        })\n        //将本次属性试图需要高亮的节点列表清空\n        this.attr_ele_brushed_data_idList = []\n        this.RootDes.forEach(ele=>{\n          this.attr_ele_brushed_data.forEach(ei=>{\n            if(ele.data.data[ei.type]==ei.name){\n              d3.select(this.$el).select('#indentedpixeltreeplots')\n                .select('#node-id-' + ele.data.data.nodeIndex).classed(\"attr-brush-highlight\", true);\n              this.attr_ele_brushed_data_idList.push(ele.data.data.nodeIndex)\n            }\n          })\n        })\n        // console.log(this.attr_ele_brushed_data_idList)\n\n      }else{\n        //当属性视图传过来的数据是空列表时，仍需清空上一次属性视图需要高亮的节点\n        this.attr_ele_brushed_data_idList.forEach(eleid=>{\n          d3.select(this.$el).select('#indentedpixeltreeplots')\n            .select('#node-id-' + eleid).classed(\"attr-brush-highlight\", false);\n        })\n        this.attr_ele_brushed_data_idList = []\n        //treeIn 以及 treeOut 再变亮\n        this.dataHighLight_In_and_Out('indentedpixeltreeplots', this.dataHighLight, bus, this.RootDes, 1)\n        d3.select(this.$el).select('#indentedpixeltreeplots').selectAll('.tree-node').classed(this.hightLightType+'-highlight', true);\n      }\n    },\n    draw_indentedpixeltreeplots: function(tmpBackGroudData, width, height, needlable=false) {\n\n      let self = this\n      if(tmpBackGroudData['data'] == null || typeof tmpBackGroudData == 'undefined') return;\n\n      let data = tmpBackGroudData['data']\n      let hightLightType = tmpBackGroudData['type']\n      self.hightLightType = hightLightType\n\n      let min_width_height = Math.min(width, height);\n      let trbl = (min_width_height * 20) / self.scale;\n      let margin = { top: trbl, right: trbl, bottom: trbl, left: trbl };\n      let innerWidth = width - margin.left;\n      let innerHeight = height - margin.top;\n      \n      let islinkHorizontal = 1;\n      \n      let padding_r = (min_width_height *((0.2+min_width_height*0.2/self.scale))) / self.scale;    \n\n      let addIndex = function(data){\n        let i = 0;\n        return d3.hierarchy(data)\n          .eachBefore(d=>{\n            d.nodeIndex = d.data.data.nodeIndex; // 标记节点的唯一标识\n            d.data.data.depth = d.depth; \n            d.data.data.height = d.height;\n            d.data.data.degree = d.children ? d.children.length : 0\n          })\n          .sum(d=>d.children ? 0 : 1).eachBefore(d=>d.index = i++); //index是另外节点序号\n      };\n\n      let root = addIndex(data)\n\n      let DimGray = d3.rgb(105,105,105)\n      // let LightGray = d3.rgb(211,211,211)\n      let linear = d3.scaleLinear().domain([0, root.height]).range([0, 1])\n      let color = d3.interpolate(DimGray, DimGray)\n      self.RootDes = root.descendants()\n      let RootDes = self.RootDes\n      let fillOpacity = 1;\n\n      let treeHeight = root.height+1\n      let rectHeight = innerHeight / treeHeight\n      let rectWidth = innerWidth / (RootDes.length*(1+padding_r))\n\n      let svg = d3.select(this.$el).select('#indentedpixeltreeplots')\n\n      let t = svg.transition()\n        .duration(750)\n          \n      let g = svg.select('#g-level-1')\n        .attr('transform', `translate(${margin.left/2}, ${margin.top/2})`);\n          \n      if(islinkHorizontal==0){\n        // g.attr('transform', `translate(${innerWidth + margin.left/2}, ${margin.top/2}) rotate(${90}) translate(${0},${-margin.top/3.5})`);\n        //mirror.T\n        g.attr('transform', `translate(${innerWidth + margin.left/2}, ${margin.top/2}) rotate(${90}) translate(${0},${innerWidth}) scale(1,-1)`);\n        let tmp = innerHeight\n        innerHeight = innerWidth\n        innerWidth = tmp\n        treeHeight = root.height + 1\n        rectHeight = innerHeight / treeHeight\n        rectWidth = innerWidth /  (RootDes.length*(1+padding_r))\n      }\n\n      let node = g.select('#g-level-1-node')\n        .attr('class', 'brush')\n        .call(brush)\n      .selectAll('a')\n        .data(RootDes, function(d, i) {\n          let node_id = d.data.data.nodeIndex\n          return node_id;\n        })\n        .join(\n          enter => enter.append('a'),\n          update => update\n            .call(update => update.transition(t)),\n          exit => exit\n            .remove()\n        )\n              \n      d3.select(self.$el).select('#indentedpixeltreeplots').selectAll('.tree-node').remove();\n      node.append(\"rect\")\n        .attr('class', 'tree-node')\n        .attr('id', d=> 'node-id-' + d.nodeIndex)\n        .attr('y', d=>{d.y = d.depth * rectHeight; return d.y})\n        .attr('x', d=>{d.x = d.index * rectWidth*(1+padding_r); return d.x})\n        .attr('width', rectWidth)\n        .attr('height', rectHeight)\n        .attr(\"fill\", d => color(linear(d.depth)))\n        .attr('fill-opacity',fillOpacity)\n        .call(self.tooltip_ele(\"indentedpixeltreeplots\", margin.left, margin.top));\n      // console.log(node)\n      d3.select(self.$el).select('#indentedpixeltreeplots').selectAll('.tree-node').classed(hightLightType+'-highlight', true);\n      \n      function brush(cell) {\n        const brush = d3.brush()\n          .extent([[-margin.left/2, -margin.top/2], [width, height]])\n          .on(\"start\", brushstarted)\n          .on(\"brush\", brushed)\n          .on(\"end\", brushended);\n        cell.call(brush);\n\n        let brushCell;\n        let selected = []\n        function brushstarted() {\n          if (brushCell !== this) {\n            d3.select(brushCell).call(brush.move, null);\n            brushCell = this;\n          }\n          // console.log(\"brush开始\")\n        }\n\n        function brushed() {\n          // console.log(\"brush\")\n          if (d3.event.selection == null) return; //刷选的区域为空时直接返回\n          selected.forEach(ele=>{\n            d3.select(self.$el).select('#indentedpixeltreeplots').select('#node-id-' + ele.data.data.nodeIndex ).classed(\"brush-highlight\", false);\n          })\n          const [[x0, y0], [x1, y1]] = d3.event.selection;\n          selected = RootDes.filter(\n            d => x0 <= d.index * rectWidth*(1+padding_r)//d.x\n              && x1 >= d.index * rectWidth*(1+padding_r) + rectWidth//d.x\n              && y0 <= d.depth * rectHeight//d.y\n              && y1 >= d.depth * rectHeight + rectHeight);//d.y\n          \n          self.dataHighLight_In_and_Out('indentedpixeltreeplots', self.dataHighLight, bus, self.RootDes, 0)\n          d3.select(self.$el).select('#indentedpixeltreeplots').selectAll('.tree-node').classed(hightLightType+'-highlight', false);\n\n          selected.forEach(ele=>{\n            d3.select(self.$el).select('#indentedpixeltreeplots').select('#node-id-' + ele.data.data.nodeIndex ).classed(\"brush-highlight\", true);\n          })\n\n          // console.log(\"树上刷选的数据:\", selected.map(d=>d.data))\n          bus.$emit('brushed_data', selected.map(d=>d.data))//传递刷选的数据到属性视图\n        }\n\n        function brushended() {\n          if (d3.event.selection != null){\n            return;\n          }\n          else{\n            //当d3.event.selection == null 时，将之前的刷选清除掉\n            selected.forEach(ele=>{\n              d3.select(self.$el).select('#indentedpixeltreeplots').select('#node-id-' + ele.data.data.nodeIndex ).classed(\"brush-highlight\", false);\n            })\n\n            d3.select(self.$el).select('#indentedpixeltreeplots').selectAll('.tree-node').classed(hightLightType+'-highlight', true);\n            self.dataHighLight_In_and_Out('indentedpixeltreeplots', self.dataHighLight, bus, self.RootDes, 1)\n\n            // bus.$emit('brushed_data', [])\n            // console.log(\"brush结束\")\n            return;\n          }\n        }\n\n      }\n\n    }\n  }\n}\n</script>\n\n<style scoped lang=\"less\">\n.canvas {\n  width: 100%;\n  height: 100%;\n  .inner-canvas {\n    width: 100%;\n    height: 100%;\n  }\n}\n</style>\n\n<style lang=\"less\">\n@stroke-line:#555;\n\n.gLink{\n  fill: none;\n  stroke: @stroke-line;\n}\n\n.attr-brush-highlight{\n  stroke: white;\n  stroke-opacity: 1;\n  stroke-width: 1.5px;\n  fill: #ff6347;\n}\n\n.brush-highlight {\n  stroke: white;\n  stroke-opacity: 1;\n  stroke-width: 1.5px;\n  // r: 5px;\n  fill: #ff6347;\n}\n\n.wholeTree-highlight{\n  stroke: white;\n  stroke-opacity: 1;\n  stroke-width: 1.5px;\n  fill: rgb(105,105,105);\n}\n\n.treeIn-highlight{\n  stroke: white;\n  stroke-opacity: 1;\n  stroke-width: 1.5px;\n  // r: 5px;\n  fill: steelblue;\n}\n\n.treeOut-highlight{\n  stroke: white;\n  stroke-opacity: 1;\n  stroke-width: 1.5px;\n  // r: 5px;\n  fill: rgb(255, 99, 71);\n}\n\n.tree-node{\n  stroke: white;\n  stroke-width: 0.2px;\n}\n</style>"]}]}