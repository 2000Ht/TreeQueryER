{"remainingRequest":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/babel-loader/lib/index.js!/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/eslint-loader/index.js??ref--13-0!/Users/ht.mi/Downloads/RETree-main/FrontEnd/src/data/dataset.js","dependencies":[{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/src/data/dataset.js","mtime":1648714649000},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":1660192275271},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/babel-loader/lib/index.js","mtime":1660192275351},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/eslint-loader/index.js","mtime":1660192275000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.object.keys\";\nexport function Dataset() {\n  this.hierarchyData = {};\n  this.regexDataList = [];\n  this.curIndex = 0;\n  this.hierarchyDataIn = [];\n  this.hierarchyDataOut = [];\n  this.connection = [];\n  this.initialData = {};\n  this.nodeRegexList = [];\n}\nimport { getComponentKey } from '@/utils/componentkey.js';\nimport { loadHierarchicalData } from '@/data/dataloading.js';\nimport { tychei } from 'seedrandom';\nDataset.prototype = {\n  init: function init() {},\n  initData: function initData(data) {\n    this.initialData = data;\n  },\n  returnInitData: function returnInitData() {\n    return this.initialData;\n  },\n  initialRegexNode: function initialRegexNode() {\n    var regex = {\n      \"target\": {\n        \"type\": \"target\",\n        \"composition\": [{\n          \"type\": \"path\",\n          \"repeat\": [1, 1],\n          \"key\": getComponentKey(),\n          \"composition\": [// {          \n            //     \"type\": \"node\",\n            //     \"repeat\": [1,1],\n            //     \"data\": {},\n            //     \"key\": getComponentKey()\n            // }\n          ]\n        }]\n      },\n      \"condition\": {\n        \"attribute\": \"size\",\n        \"op\": \"max\",\n        \"value\": \"\"\n      },\n      \"regexName\": 'untitled'\n    };\n    var tmpData1 = {};\n    var tmpData2 = [[]];\n    var tmpList = [];\n    var tmpNodeList = [{\n      'data': {},\n      'nodeName': '.',\n      'nodeColor': '#8E9898'\n    }, {\n      'data': {\n        \"depth\": {\n          \"op\": \"=\",\n          \"value\": 0\n        }\n      },\n      'nodeName': '^',\n      'nodeColor': '#D2BA4D'\n    }, {\n      'data': {\n        \"degree\": {\n          \"op\": \"=\",\n          \"value\": 0\n        }\n      },\n      'nodeName': '$',\n      'nodeColor': '#38B03F'\n    }];\n    this.hierarchyDataIn.push(tmpData1);\n    this.hierarchyDataOut.push(tmpData2);\n    this.regexDataList.push(regex);\n    this.connection.push(tmpList);\n    this.nodeRegexList.push(tmpNodeList);\n    this.curIndex = this.curIndex + 1;\n    return this.curIndex - 1;\n  },\n  resetRegex: function resetRegex(index) {\n    var tmpName = this.regexDataList[index]['regexName'];\n    this.regexDataList[index] = {\n      \"target\": {\n        \"type\": \"target\",\n        \"composition\": [{\n          \"type\": \"path\",\n          \"repeat\": [1, 1],\n          \"key\": getComponentKey(),\n          \"composition\": [// {          \n            //     \"type\": \"node\",\n            //     \"repeat\": [1,1],\n            //     \"data\": {},\n            //     \"key\": getComponentKey()\n            // }\n          ]\n        }]\n      },\n      \"condition\": {\n        \"attribute\": \"size\",\n        \"op\": \"max\",\n        \"value\": \"\"\n      },\n      \"dataIndex\": index,\n      \"regexName\": tmpName\n    };\n  },\n  returnRegex: function returnRegex(index) {\n    return this.regexDataList[index];\n  },\n  returnRegexContent: function returnRegexContent(index) {\n    return this.regexDataList[index]['regexContent'];\n  },\n  returnHierarchyDataIn: function returnHierarchyDataIn(index) {\n    if (Object.keys(this.hierarchyDataIn[index]).length == 0) {\n      return [this.initialData];\n    } else {\n      var tmpList = [];\n\n      for (var key in this.hierarchyDataIn[index]) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.hierarchyDataIn[index][key][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var tmpTree = _step.value;\n            tmpList.push(tmpTree);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return tmpList;\n    }\n  },\n  updateHierarchyDataOut: function updateHierarchyDataOut(processed_hierarchy_data, index) {\n    this.hierarchyDataOut[index] = processed_hierarchy_data['data'];\n  },\n  returnHierarchyDataOut: function returnHierarchyDataOut(index) {\n    return this.hierarchyDataOut[index];\n  },\n  DataOut2DataIn: function DataOut2DataIn(indexOut, indexIn) {\n    this.connection[indexOut].push(indexIn);\n    this.hierarchyDataIn[indexIn][indexOut] = [];\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = this.hierarchyDataOut[indexOut][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var item = _step2.value;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = item[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var tmpTree = _step3.value;\n            this.hierarchyDataIn[indexIn][indexOut].push(tmpTree);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  },\n  DataOutFlow: function DataOutFlow(index) {\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = this.connection[index][Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var nextIndex = _step4.value;\n        this.hierarchyDataIn[nextIndex][index] = [];\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = this.hierarchyDataOut[index][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var item = _step5.value;\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n              for (var _iterator6 = item[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                var tmpTree = _step6.value;\n                this.hierarchyDataIn[nextIndex][index].push(tmpTree);\n              }\n            } catch (err) {\n              _didIteratorError6 = true;\n              _iteratorError6 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                  _iterator6.return();\n                }\n              } finally {\n                if (_didIteratorError6) {\n                  throw _iteratorError6;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  },\n  returnConnection: function returnConnection(index) {\n    return this.connection[index];\n  },\n  UpdataNodeList: function UpdataNodeList(node, index) {\n    var flag = true;\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n      for (var _iterator7 = this.nodeRegexList[index][Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n        var _tmpNode = _step7.value;\n        var len1 = Object.keys(node['data']).length;\n        var len2 = Object.keys(_tmpNode['data']).length;\n\n        if (len1 == 0 && len2 == 0) {\n          if (node['nodeName'] == _tmpNode['nodeName'] && node['nodeColor'] == _tmpNode['nodeColor']) {\n            flag = false;\n            break;\n          }\n        } else if (len1 == len2) {\n          var tmpData = _tmpNode['data'];\n          var tmpFlag = true;\n\n          for (var tmpKey in tmpData) {\n            if (tmpKey in node['data']) {\n              if (tmpData[tmpKey]['op'] == node['data'][tmpKey]['op']) {\n                if (tmpData[tmpKey]['value'] == node['data'][tmpKey]['value']) {\n                  continue;\n                }\n              }\n            }\n\n            tmpFlag = false;\n            break;\n          }\n\n          if (tmpFlag) {\n            if (node['nodeName'] == _tmpNode['nodeName'] && node['nodeColor'] == _tmpNode['nodeColor']) {\n              flag = false;\n              break;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError7 = true;\n      _iteratorError7 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n          _iterator7.return();\n        }\n      } finally {\n        if (_didIteratorError7) {\n          throw _iteratorError7;\n        }\n      }\n    }\n\n    if (flag) {\n      var tmpNode = {\n        'type': 'listNode',\n        'data': {},\n        'nodeName': '',\n        'nodeColor': ''\n      };\n      tmpNode['nodeName'] = node['nodeName'];\n      tmpNode['nodeColor'] = node['nodeColor'];\n      tmpNode['data'] = JSON.parse(JSON.stringify(node['data']));\n      tmpNode['key'] = getComponentKey();\n      this.nodeRegexList[index].push(tmpNode);\n    } //this.nodeRegexList[index].push(node)\n\n  },\n  returnNodeList: function returnNodeList(index) {\n    return this.nodeRegexList[index];\n  },\n  updateRegexName: function updateRegexName(name, index) {\n    this.regexDataList[index]['regexName'] = name;\n  },\n  returnRegexName: function returnRegexName(index) {\n    return this.regexDataList[index]['regexName'];\n  },\n  deleteDataConnection: function deleteDataConnection(indexOut, indexIn) {\n    var _this = this;\n\n    this.connection[indexOut].map(function (val, i) {\n      if (val == indexIn) {\n        _this.connection[indexOut].splice(i, 1);\n      }\n    });\n    delete this.hierarchyDataIn[indexIn][indexOut];\n  },\n  deleteDataNode: function deleteDataNode(index) {\n    for (var key in this.hierarchyDataIn[index]) {\n      this.deleteDataConnection(key, index);\n    }\n\n    var _iteratorNormalCompletion8 = true;\n    var _didIteratorError8 = false;\n    var _iteratorError8 = undefined;\n\n    try {\n      for (var _iterator8 = this.connection[index][Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n        var tmpIndex = _step8.value;\n        this.deleteDataConnection(index, tmpIndex);\n      }\n    } catch (err) {\n      _didIteratorError8 = true;\n      _iteratorError8 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n          _iterator8.return();\n        }\n      } finally {\n        if (_didIteratorError8) {\n          throw _iteratorError8;\n        }\n      }\n    }\n  }\n};",{"version":3,"sources":["/Users/ht.mi/Downloads/RETree-main/FrontEnd/src/data/dataset.js"],"names":["Dataset","hierarchyData","regexDataList","curIndex","hierarchyDataIn","hierarchyDataOut","connection","initialData","nodeRegexList","getComponentKey","loadHierarchicalData","tychei","prototype","init","initData","data","returnInitData","initialRegexNode","regex","tmpData1","tmpData2","tmpList","tmpNodeList","push","resetRegex","index","tmpName","returnRegex","returnRegexContent","returnHierarchyDataIn","Object","keys","length","key","tmpTree","updateHierarchyDataOut","processed_hierarchy_data","returnHierarchyDataOut","DataOut2DataIn","indexOut","indexIn","item","DataOutFlow","nextIndex","returnConnection","UpdataNodeList","node","flag","tmpNode","len1","len2","tmpData","tmpFlag","tmpKey","JSON","parse","stringify","returnNodeList","updateRegexName","name","returnRegexName","deleteDataConnection","map","val","i","splice","deleteDataNode","tmpIndex"],"mappings":"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","sourcesContent":["export function Dataset () {\n    this.hierarchyData = {}\n    this.regexDataList = []\n    this.curIndex = 0\n    this.hierarchyDataIn = []\n    this.hierarchyDataOut = []\n    this.connection = []\n    this.initialData = {}\n    this.nodeRegexList = []\n}\n\nimport { getComponentKey } from '@/utils/componentkey.js'\nimport { loadHierarchicalData } from '@/data/dataloading.js'\nimport { tychei } from 'seedrandom'\n\nDataset.prototype = {\n    init: function() {\n    },\n    initData: function(data){\n      this.initialData = data\n    },\n    returnInitData: function(){\n      return this.initialData\n    },\n    initialRegexNode: function(){\n        let regex = {\n            \"target\":{\n              \"type\": \"target\",\n              \"composition\":[\n                {\n                  \"type\": \"path\",\n                  \"repeat\": [1,1],\n                  \"key\": getComponentKey(),\n                  \"composition\":[\n                    // {          \n                    //     \"type\": \"node\",\n                    //     \"repeat\": [1,1],\n                    //     \"data\": {},\n                    //     \"key\": getComponentKey()\n                    // }\n                  ]\n                }\n              ]\n    \n            },\n            \"condition\": {\n              \"attribute\": \"size\",\n              \"op\": \"max\",\n              \"value\": \"\"\n            },\n            \"regexName\": 'untitled'\n        }\n        let tmpData1 = {}\n        let tmpData2 = [[]]\n        let tmpList = []\n        let tmpNodeList = [\n          {\n            'data':{},\n            'nodeName':'.',\n            'nodeColor': '#8E9898',\n          },\n          {\n            'data':{\"depth\":{\"op\":\"=\",\"value\":0}},\n            'nodeName':'^',\n            'nodeColor': '#D2BA4D',\n          },\n          {\n            'data':{\"degree\":{\"op\":\"=\",\"value\":0}},\n            'nodeName':'$',\n            'nodeColor': '#38B03F',\n          }\n        ]\n        this.hierarchyDataIn.push(tmpData1)\n        this.hierarchyDataOut.push(tmpData2)\n        this.regexDataList.push(regex)\n        this.connection.push(tmpList)\n        this.nodeRegexList.push(tmpNodeList)\n        this.curIndex = this.curIndex + 1\n        return this.curIndex - 1\n    },\n    resetRegex: function(index){\n      let tmpName = this.regexDataList[index]['regexName']\n        this.regexDataList[index] = {\n            \"target\":{\n              \"type\": \"target\",\n              \"composition\":[\n                {\n                  \"type\": \"path\",\n                  \"repeat\": [1,1],\n                  \"key\": getComponentKey(),\n                  \"composition\":[\n                    // {          \n                    //     \"type\": \"node\",\n                    //     \"repeat\": [1,1],\n                    //     \"data\": {},\n                    //     \"key\": getComponentKey()\n                    // }\n                  ]\n                }\n              ]\n    \n            },\n            \"condition\": {\n              \"attribute\": \"size\",\n              \"op\": \"max\",\n              \"value\": \"\"\n            },\n            \"dataIndex\": index,\n            \"regexName\": tmpName\n          }\n    },\n    returnRegex: function(index){\n        return this.regexDataList[index]\n    },\n    returnRegexContent: function(index){\n      return this.regexDataList[index]['regexContent']\n  },\n    returnHierarchyDataIn: function(index) {\n      if(Object.keys(this.hierarchyDataIn[index]).length == 0){\n        return [this.initialData]\n      }\n      else{\n        let tmpList = []\n        for(let key in this.hierarchyDataIn[index]){\n          for(let tmpTree of this.hierarchyDataIn[index][key]){\n            tmpList.push(tmpTree)\n          }\n        }\n        return tmpList\n      }\n      \n    },\n    \n    updateHierarchyDataOut: function(processed_hierarchy_data, index) {\n      this.hierarchyDataOut[index] = processed_hierarchy_data['data']\n    },\n    returnHierarchyDataOut: function(index) {\n      return this.hierarchyDataOut[index]\n    },\n\n    DataOut2DataIn: function(indexOut, indexIn) {\n      this.connection[indexOut].push(indexIn)\n      this.hierarchyDataIn[indexIn][indexOut] = []\n      for(let item of this.hierarchyDataOut[indexOut]){\n        for(let tmpTree of item){\n          this.hierarchyDataIn[indexIn][indexOut].push(tmpTree)\n        }\n      }\n    },\n\n    DataOutFlow: function(index){\n      for(let nextIndex of this.connection[index]){\n        this.hierarchyDataIn[nextIndex][index] = []\n        for(let item of this.hierarchyDataOut[index]){\n          for(let tmpTree of item){\n            this.hierarchyDataIn[nextIndex][index].push(tmpTree)\n          }\n        }\n      }\n    },\n    returnConnection: function(index){\n      return this.connection[index]\n    },\n\n    UpdataNodeList: function(node, index){\n      let flag = true\n      for(let tmpNode of this.nodeRegexList[index]){\n        let len1 = Object.keys(node['data']).length\n        let len2 =  Object.keys(tmpNode['data']).length\n        if(len1==0 && len2==0){\n          if(node['nodeName']==tmpNode['nodeName'] && node['nodeColor']==tmpNode['nodeColor']){\n            flag = false \n            break\n          }\n        }\n        else if(len1==len2){\n          let tmpData = tmpNode['data']\n          let tmpFlag = true\n          for(let tmpKey in tmpData){\n            if(tmpKey in node['data']){\n              if(tmpData[tmpKey]['op']==node['data'][tmpKey]['op']){\n                if(tmpData[tmpKey]['value']==node['data'][tmpKey]['value']){\n                  continue                  \n                }\n              }\n            }  \n            tmpFlag = false\n            break\n          }\n          if(tmpFlag){\n            if(node['nodeName']==tmpNode['nodeName'] && node['nodeColor']==tmpNode['nodeColor']){\n              flag = false \n              break\n            }\n          }\n        }\n      }\n      if(flag){\n        let tmpNode = {\n          'type': 'listNode',\n          'data':{},\n          'nodeName':'',\n          'nodeColor': '',\n        }\n        tmpNode['nodeName'] = node['nodeName']\n        tmpNode['nodeColor'] = node['nodeColor']\n        tmpNode['data'] = JSON.parse(JSON.stringify(node['data']))\n        tmpNode['key'] = getComponentKey()     \n        this.nodeRegexList[index].push(tmpNode)\n        \n      }\n      //this.nodeRegexList[index].push(node)\n    },\n    returnNodeList: function(index){\n      return this.nodeRegexList[index]\n    },\n    updateRegexName: function(name, index){\n      this.regexDataList[index]['regexName'] = name\n    },\n    returnRegexName: function(index){\n      return this.regexDataList[index]['regexName']\n    },\n\n    deleteDataConnection: function(indexOut, indexIn){\n      this.connection[indexOut].map((val, i) => {\n        if(val == indexIn){\n          this.connection[indexOut].splice(i ,1)\n        }\n      })\n      delete this.hierarchyDataIn[indexIn][indexOut]\n    },\n    deleteDataNode: function(index){\n      for(let key in this.hierarchyDataIn[index]){\n        this.deleteDataConnection(key, index)\n      }\n      for(let tmpIndex of this.connection[index]){\n        this.deleteDataConnection(index, tmpIndex)\n      }\n    },\n\n\n}"]}]}