{"remainingRequest":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/babel-loader/lib/index.js!/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ht.mi/Downloads/RETree-main/FrontEnd/src/components/flowchart/Flowchart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/src/components/flowchart/Flowchart.vue","mtime":1648714649000},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":1660192275271},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/babel-loader/lib/index.js","mtime":1660192275351},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/cache-loader/dist/cjs.js","mtime":1660192275271},{"path":"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/vue-loader/lib/index.js","mtime":1660192275522}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es6.object.keys\";\nimport _typeof from \"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/@babel/runtime-corejs2/helpers/esm/typeof\";\nimport \"core-js/modules/es6.math.hypot\";\nimport _toConsumableArray from \"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.math.trunc\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"/Users/ht.mi/Downloads/RETree-main/FrontEnd/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.number.constructor\";\n\nvar _name$props$data$watc;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { line2, lineTo } from \"../../utils/svg\";\nimport { mapState, mapMutations } from 'vuex';\nimport * as d3 from \"d3\";\nimport { roundTo20, between, distanceOfPointToLine, getEdgeOfPoints, pointRectangleIntersection } from \"../../utils/math\";\nimport render from \"./render\";\nexport default (_name$props$data$watc = {\n  name: \"flowchart\",\n  props: {\n    nodes: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    connections: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    width: {\n      type: [String, Number],\n      default: 800\n    },\n    height: {\n      type: [String, Number],\n      default: 600\n    },\n    readonly: {\n      type: Boolean,\n      default: false\n    },\n    excludeShownAttrArray: {\n      type: Array,\n      default: []\n    }\n  },\n  data: function data() {\n    return {\n      internalNodes: [],\n      internalConnections: [],\n      connectingInfo: {\n        source: null,\n        sourcePosition: null\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: {\n        x: 0,\n        y: 0\n      },\n      clickedOnce: false,\n      pathClickedOnce: false,\n\n      /**\n       * lines of all internalConnections\n       */\n      lines: [],\n      canvasId: \"svg\",\n      regexContent: \"\",\n      regexContentFlag: false\n    };\n  },\n  watch: {\n    regexContentState: function regexContentState() {\n      this.regexContent = sysDatasetObj.returnRegexContent(this.curRegexIndex);\n    }\n  },\n  computed: _objectSpread({}, mapState(['regexContentState', 'curRegexIndex'])),\n  methods: _objectSpread({}, mapMutations(['UPDATE_VISVIEW', 'UPDATE_CURRENT_REGEX', 'UPDATE_CONNECTION']), {\n    addComponent: function addComponent() {\n      var tmpNode = {\n        type: 'query',\n        color: '#ff7f00',\n        name: 'query'\n      };\n      this.$emit(\"addComponent\", tmpNode);\n    },\n    add: function add(node) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.internalNodes.push(node);\n    },\n    editCurrent: function editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode: function editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"editnode\", node);\n    },\n    editConnection: function editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"editconnection\", connection);\n    },\n    refresh: function refresh() {\n      console.log('refresh whole view');\n    },\n    handleChartMouseWheel: function handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n\n      if (event.ctrlKey) {\n        var svg = document.getElementById(\"svg\");\n        var zoom = parseFloat(svg.style.zoom || 1);\n\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    handleChartMouseUp: function () {\n      var _handleChartMouseUp = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        var tempId, conn, tmpSource, tmpDestination;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.connectingInfo.source) {\n                  if (this.hoveredConnector) {\n                    if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n                      // Node can't connect to itself\n                      tempId = +new Date();\n                      conn = {\n                        source: {\n                          id: this.connectingInfo.source.id,\n                          position: this.connectingInfo.sourcePosition\n                        },\n                        destination: {\n                          id: this.hoveredConnector.node.id,\n                          position: this.hoveredConnector.position\n                        },\n                        id: tempId,\n                        type: \"pass\",\n                        name: \"Pass\"\n                      };\n                      tmpSource = this.internalNodes.filter(function (item) {\n                        return item.id === conn['source']['id'];\n                      })[0];\n                      tmpDestination = this.internalNodes.filter(function (item) {\n                        return item.id === conn['destination']['id'];\n                      })[0];\n                      sysDatasetObj.DataOut2DataIn(tmpSource['regexIndex'], tmpDestination['regexIndex']);\n                      this.UPDATE_CONNECTION(tmpDestination['regexIndex']);\n                      this.internalConnections.push(conn);\n                    }\n                  }\n\n                  this.connectingInfo.source = null;\n                  this.connectingInfo.sourcePosition = null;\n                }\n\n                if (this.selectionInfo) {\n                  this.selectionInfo = null;\n                }\n\n                this.regexContentFlag = false;\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handleChartMouseUp() {\n        return _handleChartMouseUp.apply(this, arguments);\n      }\n\n      return handleChartMouseUp;\n    }(),\n    handleChartMouseMove: function () {\n      var _handleChartMouseMove = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2(event) {\n        var svg, zoom, boundingClientRect, actualX, actualY, sourceOffset, destinationPosition;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // calc offset of cursor to chart\n                svg = document.getElementById(\"svg\");\n                zoom = svg.style.zoom; // the size ratio of the whole canvas\n\n                if (zoom.length == 0) {\n                  zoom = 1;\n                }\n\n                zoom = parseFloat(zoom);\n                boundingClientRect = event.currentTarget.getBoundingClientRect();\n                actualX = event.pageX - boundingClientRect.left - window.scrollX;\n                actualX = actualX / zoom;\n                this.cursorToChartOffset.x = Math.trunc(actualX);\n                actualY = event.pageY - boundingClientRect.top - window.scrollY;\n                actualY = actualY / zoom;\n                this.cursorToChartOffset.y = Math.trunc(actualY);\n\n                if (!this.connectingInfo.source) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                _context2.next = 14;\n                return this.renderConnections();\n\n              case 14:\n                d3.selectAll(\"#svg .connector\").classed(\"active\", true);\n                sourceOffset = this.getNodeConnectorOffset(this.connectingInfo.source.id, this.connectingInfo.sourcePosition);\n                destinationPosition = this.hoveredConnector ? this.hoveredConnector.position : null;\n                this.arrowTo(sourceOffset.x, sourceOffset.y, this.cursorToChartOffset.x, this.cursorToChartOffset.y, this.connectingInfo.sourcePosition, false, destinationPosition);\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function handleChartMouseMove(_x) {\n        return _handleChartMouseMove.apply(this, arguments);\n      }\n\n      return handleChartMouseMove;\n    }(),\n    handleChartMouseDown: function handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n\n      this.selectionInfo = {\n        x: event.offsetX,\n        y: event.offsetY\n      };\n    },\n    getConnectorPosition: function getConnectorPosition(node) {\n      var halfWidth = node.width / 2;\n      var halfHeight = node.height / 2;\n      var top = {\n        x: node.x + halfWidth,\n        y: node.y\n      };\n      var left = {\n        x: node.x,\n        y: node.y + halfHeight\n      };\n      var bottom = {\n        x: node.x + halfWidth,\n        y: node.y + node.height\n      };\n      var right = {\n        x: node.x + node.width,\n        y: node.y + halfHeight\n      };\n      return {\n        left: left,\n        right: right,\n        top: top,\n        bottom: bottom\n      };\n    },\n    renderSelection: function renderSelection() {\n      var that = this; // render selection rectangle\n\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        var edge = getEdgeOfPoints([{\n          x: that.selectionInfo.x,\n          y: that.selectionInfo.y\n        }, {\n          x: that.cursorToChartOffset.x,\n          y: that.cursorToChartOffset.y\n        }]);\n        var svg = d3.select(\"#svg\");\n        var rect = svg.select(\".selection\").classed(\"active\", true);\n        rect.attr(\"x\", edge.start.x).attr(\"y\", edge.start.y).attr(\"width\", edge.end.x - edge.start.x).attr(\"height\", edge.end.y - edge.start.y);\n        that.internalNodes.forEach(function (item) {\n          var points = [{\n            x: item.x,\n            y: item.y\n          }, {\n            x: item.x,\n            y: item.y + item.height\n          }, {\n            x: item.x + item.width,\n            y: item.y\n          }, {\n            x: item.x + item.width,\n            y: item.y + item.height\n          }];\n\n          if (points.every(function (point) {\n            return pointRectangleIntersection(point, edge);\n          })) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach(function (line) {\n          var points = [{\n            x: line.sourceX,\n            y: line.sourceY\n          }, {\n            x: line.destinationX,\n            y: line.destinationY\n          }];\n\n          if (points.every(function (point) {\n            return pointRectangleIntersection(point, edge);\n          }) && that.currentConnections.every(function (item) {\n            return item.id !== line.id;\n          })) {\n            var connection = that.internalConnections.filter(function (conn) {\n              return conn.id === line.id;\n            })[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        d3.selectAll(\"#svg > .selection\").classed(\"active\", false);\n      }\n    },\n    renderConnections: function renderConnections() {\n      var that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          d3.selectAll(\"#svg > g.connection\").remove(); // render lines\n\n          that.lines = [];\n          that.internalConnections.forEach(function (conn) {\n            var sourcePosition = that.getNodeConnectorOffset(conn.source.id, conn.source.position);\n            var destinationPosition = that.getNodeConnectorOffset(conn.destination.id, conn.destination.position);\n            var colors = {\n              pass: \"#888888\",\n              reject: \"red\"\n            };\n            var connectionSelected = that.currentConnections.filter(function (item) {\n              return item === conn;\n            }).length > 0;\n\n            if (connectionSelected) {\n              colors = {\n                pass: \"#888888\",\n                reject: \"darkred\"\n              };\n            }\n\n            var result = that.arrowTo(sourcePosition.x, sourcePosition.y, destinationPosition.x, destinationPosition.y, conn.source.position, conn.destination.position, connectionSelected, colors[conn.type]);\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = result.paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var path = _step.value;\n                path.on(\"mousedown\", function () {\n                  d3.event.stopPropagation();\n\n                  if (that.pathClickedOnce) {\n                    that.editConnection(conn);\n                  } else {\n                    var timer = setTimeout(function () {\n                      that.pathClickedOnce = false;\n                      clearTimeout(timer);\n                    }, 300);\n                    that.pathClickedOnce = true;\n                  }\n\n                  that.currentNodes.splice(0, that.currentNodes.length);\n                  that.currentConnections.splice(0, that.currentConnections.length);\n                  that.currentConnections.push(conn);\n                });\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = result.lines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var line = _step2.value;\n                that.lines.push({\n                  sourceX: line.sourceX,\n                  sourceY: line.sourceY,\n                  destinationX: line.destinationX,\n                  destinationY: line.destinationY,\n                  id: conn.id\n                });\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes: function renderNodes() {\n      var that = this;\n      return new Promise(function (resolve) {\n        d3.selectAll(\"#svg > g.node\").remove(); // render nodes\n\n        that.internalNodes.forEach(function (node) {\n          that.renderNode(node, that.currentNodes.filter(function (item) {\n            return item === node;\n          }).length > 0);\n        });\n        resolve();\n      });\n    },\n    getNodeConnectorOffset: function getNodeConnectorOffset(nodeId, connectorPosition) {\n      var node = this.internalNodes.filter(function (item) {\n        return item.id === nodeId;\n      })[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append: function append(element) {\n      var svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo: function guideLineTo(x1, y1, x2, y2) {\n      var g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo: function arrowTo(x1, y1, x2, y2, startPosition, endPosition, connectionSelected, color) {\n      var g = this.append(\"g\");\n      g.classed(\"connection\", true);\n\n      if (connectionSelected) {\n        line2(g, x1, y1, x2, y2, startPosition, endPosition, 2.5, color || \"#a3a3a3\", true);\n      } else {\n        line2(g, x1, y1, x2, y2, startPosition, endPosition, 1, color || \"#a3a3a3\", true);\n      } // a 5px cover to make mouse operation conveniently\n\n\n      return line2(g, x1, y1, x2, y2, startPosition, endPosition, 5, \"transparent\", false);\n    },\n    renderNode: function renderNode(node, isSelected) {\n      var that = this;\n      var g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n      node.render = render;\n      node.render(g, node, isSelected, this.excludeShownAttrArray);\n      var drag = d3.drag().on(\"start\", function () {\n        // handle mousedown\n        var isNotCurrentNode = that.currentNodes.filter(function (item) {\n          return item === node;\n        }).length === 0;\n\n        if (isNotCurrentNode) {\n          that.currentConnections.splice(0, that.currentConnections.length);\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentNodes.push(node);\n        } // the drag event and click event is conflicted, \n        // so handle the drag start function of the selected nodes is equal to the double click event\n\n\n        if (that.clickedOnce) {\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.editNode(node);\n        } else {\n          that.regexContent = sysDatasetObj.returnRegexContent(node['regexIndex']);\n          that.regexContentFlag = true;\n          that.UPDATE_CURRENT_REGEX(node['regexIndex']);\n          that.UPDATE_VISVIEW();\n          var timer = setTimeout(function () {\n            that.clickedOnce = false;\n            clearTimeout(timer);\n          }, 300);\n          that.clickedOnce = true;\n        }\n      }).on(\"drag\",\n      /*#__PURE__*/\n      _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3() {\n        var zoom, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, currentNode, edge, expectX, expectY;\n\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!that.readonly) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n                _iteratorNormalCompletion3 = true;\n                _didIteratorError3 = false;\n                _iteratorError3 = undefined;\n                _context3.prev = 6;\n\n                for (_iterator3 = that.currentNodes[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                  currentNode = _step3.value;\n                  currentNode.x += d3.event.dx / zoom;\n                  currentNode.y += d3.event.dy / zoom;\n                }\n\n                _context3.next = 14;\n                break;\n\n              case 10:\n                _context3.prev = 10;\n                _context3.t0 = _context3[\"catch\"](6);\n                _didIteratorError3 = true;\n                _iteratorError3 = _context3.t0;\n\n              case 14:\n                _context3.prev = 14;\n                _context3.prev = 15;\n\n                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                  _iterator3.return();\n                }\n\n              case 17:\n                _context3.prev = 17;\n\n                if (!_didIteratorError3) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                throw _iteratorError3;\n\n              case 20:\n                return _context3.finish(17);\n\n              case 21:\n                return _context3.finish(14);\n\n              case 22:\n                d3.selectAll(\"#svg > g.guideline\").remove();\n                edge = that.getCurrentNodesEdge();\n                expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n                expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n                that.internalNodes.forEach(function (item) {\n                  if (that.currentNodes.filter(function (currentNode) {\n                    return currentNode === item;\n                  }).length === 0) {\n                    if (item.x === expectX) {\n                      // vertical guideline\n                      if (item.y < expectY) {\n                        that.guideLineTo(item.x, item.y + item.height, expectX, expectY);\n                      } else {\n                        that.guideLineTo(expectX, expectY + item.height, item.x, item.y);\n                      }\n                    }\n\n                    if (item.y === expectY) {\n                      // horizontal guideline\n                      if (item.x < expectX) {\n                        that.guideLineTo(item.x + item.width, item.y, expectX, expectY);\n                      } else {\n                        that.guideLineTo(expectX + item.width, expectY, item.x, item.y);\n                      }\n                    }\n                  }\n                });\n\n              case 27:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[6, 10, 14, 22], [15,, 17, 21]]);\n      }))).on(\"end\", function () {\n        d3.selectAll(\"#svg > g.guideline\").remove();\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = that.currentNodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var currentNode = _step4.value;\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n\n        var isNotCurrentNode = that.currentNodes.filter(function (item) {\n          return item === node;\n        }).length === 0;\n\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n      var connectors = [];\n      var connectorPosition = this.getConnectorPosition(node);\n\n      var _loop = function _loop(position) {\n        var positionElement = connectorPosition[position];\n        var connector = g.append(\"circle\").attr(\"cx\", positionElement.x).attr(\"cy\", positionElement.y).attr(\"r\", 4).attr(\"class\", \"connector\");\n        connector.on(\"mousedown\", function () {\n          d3.event.stopPropagation();\n\n          if (node.type === \"end\" || that.readonly) {\n            return;\n          }\n\n          that.connectingInfo.source = node;\n          that.connectingInfo.sourcePosition = position;\n        }).on(\"mouseup\", function () {\n          d3.event.stopPropagation();\n\n          if (that.connectingInfo.source) {\n            if (that.connectingInfo.source.id !== node.id) {\n              // Node can't connect to itself\n              var tempId = +new Date();\n              var conn = {\n                source: {\n                  id: that.connectingInfo.source.id,\n                  position: that.connectingInfo.sourcePosition\n                },\n                destination: {\n                  id: node.id,\n                  position: position\n                },\n                id: tempId,\n                type: \"pass\",\n                name: \"Pass\"\n              };\n              that.internalConnections.push(conn);\n            }\n\n            that.connectingInfo.source = null;\n            that.connectingInfo.sourcePosition = null;\n          }\n        }).on(\"mouseover\", function () {\n          connector.classed(\"active\", true);\n        }).on(\"mouseout\", function () {\n          connector.classed(\"active\", false);\n        });\n        connectors.push(connector);\n      };\n\n      for (var position in connectorPosition) {\n        _loop(position);\n      }\n\n      g.on(\"mouseover\", function () {\n        connectors.forEach(function (conn) {\n          return conn.classed(\"active\", true);\n        });\n      }).on(\"mouseout\", function () {\n        connectors.forEach(function (conn) {\n          return conn.classed(\"active\", false);\n        });\n      });\n    },\n    getCurrentNodesEdge: function getCurrentNodesEdge() {\n      var points = this.currentNodes.map(function (node) {\n        return {\n          x: node.x,\n          y: node.y\n        };\n      });\n      points.push.apply(points, _toConsumableArray(this.currentNodes.map(function (node) {\n        return {\n          x: node.x + node.width,\n          y: node.y + node.height\n        };\n      })));\n      return getEdgeOfPoints(points);\n    },\n    save: function save() {\n      if (this.readonly) {\n        return;\n      }\n\n      this.$emit(\"save\", this.internalNodes, this.internalConnections);\n    },\n    remove: function () {\n      var _remove = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee4() {\n        var _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, conn, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, node;\n\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.readonly) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                if (!(this.currentConnections.length > 0)) {\n                  _context4.next = 23;\n                  break;\n                }\n\n                _iteratorNormalCompletion5 = true;\n                _didIteratorError5 = false;\n                _iteratorError5 = undefined;\n                _context4.prev = 6;\n\n                for (_iterator5 = this.currentConnections[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                  conn = _step5.value;\n                  this.removeConnection(conn);\n                }\n\n                _context4.next = 14;\n                break;\n\n              case 10:\n                _context4.prev = 10;\n                _context4.t0 = _context4[\"catch\"](6);\n                _didIteratorError5 = true;\n                _iteratorError5 = _context4.t0;\n\n              case 14:\n                _context4.prev = 14;\n                _context4.prev = 15;\n\n                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                  _iterator5.return();\n                }\n\n              case 17:\n                _context4.prev = 17;\n\n                if (!_didIteratorError5) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                throw _iteratorError5;\n\n              case 20:\n                return _context4.finish(17);\n\n              case 21:\n                return _context4.finish(14);\n\n              case 22:\n                this.currentConnections.splice(0, this.currentConnections.length);\n\n              case 23:\n                if (!(this.currentNodes.length > 0)) {\n                  _context4.next = 44;\n                  break;\n                }\n\n                _iteratorNormalCompletion6 = true;\n                _didIteratorError6 = false;\n                _iteratorError6 = undefined;\n                _context4.prev = 27;\n\n                for (_iterator6 = this.currentNodes[Symbol.iterator](); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                  node = _step6.value;\n                  this.removeNode(node);\n                }\n\n                _context4.next = 35;\n                break;\n\n              case 31:\n                _context4.prev = 31;\n                _context4.t1 = _context4[\"catch\"](27);\n                _didIteratorError6 = true;\n                _iteratorError6 = _context4.t1;\n\n              case 35:\n                _context4.prev = 35;\n                _context4.prev = 36;\n\n                if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                  _iterator6.return();\n                }\n\n              case 38:\n                _context4.prev = 38;\n\n                if (!_didIteratorError6) {\n                  _context4.next = 41;\n                  break;\n                }\n\n                throw _iteratorError6;\n\n              case 41:\n                return _context4.finish(38);\n\n              case 42:\n                return _context4.finish(35);\n\n              case 43:\n                this.currentNodes.splice(0, this.currentNodes.length);\n\n              case 44:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[6, 10, 14, 22], [15,, 17, 21], [27, 31, 35, 43], [36,, 38, 42]]);\n      }));\n\n      function remove() {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }(),\n    removeNode: function removeNode(node) {\n      var connections = this.internalConnections.filter(function (item) {\n        return item.source.id === node.id || item.destination.id === node.id;\n      });\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = connections[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var connection = _step7.value;\n          this.internalConnections.splice(this.internalConnections.indexOf(connection), 1);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      sysDatasetObj.deleteDataNode(node['regexIndex']);\n      this.internalNodes.splice(this.internalNodes.indexOf(node), 1);\n    },\n    removeConnection: function removeConnection(conn) {\n      var index = this.internalConnections.indexOf(conn);\n      var tmpSource = this.internalNodes.filter(function (item) {\n        return item.id === conn['source']['id'];\n      })[0];\n      var tmpDestination = this.internalNodes.filter(function (item) {\n        return item.id === conn['destination']['id'];\n      })[0];\n      sysDatasetObj.deleteDataConnection(tmpSource['regexIndex'], tmpDestination['regexIndex']);\n      this.internalConnections.splice(index, 1);\n    },\n    moveCurrentNode: function moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = this.currentNodes[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var node = _step8.value;\n            node.x += x;\n            node.y += y;\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      }\n    },\n    init: function init() {\n      var that = this;\n      that.internalNodes.splice(0, that.internalNodes.length);\n      that.internalConnections.splice(0, that.internalConnections.length);\n      that.nodes.forEach(function (node) {\n        var newNode = Object.assign({}, node);\n        newNode.width = newNode.width || 120;\n        newNode.height = newNode.height || 60;\n        that.internalNodes.push(newNode);\n      });\n      that.connections.forEach(function (connection) {\n        that.internalConnections.push(JSON.parse(JSON.stringify(connection)));\n      });\n    }\n  }, mapMutations(['UPDATE_HOVERING_ID'])),\n  mounted: function mounted() {\n    var that = this;\n    that.init();\n\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            var _that$currentNodes, _that$currentConnecti;\n\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n\n            (_that$currentNodes = that.currentNodes).push.apply(_that$currentNodes, _toConsumableArray(that.internalNodes));\n\n            (_that$currentConnecti = that.currentConnections).push.apply(_that$currentConnecti, _toConsumableArray(that.internalConnections));\n\n            event.preventDefault();\n          }\n\n          break;\n        // delete the selected item\n\n        case 8: // case 46:\n        //   that.remove();\n        //   break;\n\n        default:\n          break;\n      }\n    };\n  },\n  created: function created() {}\n}, _defineProperty(_name$props$data$watc, \"computed\", {\n  // ...mapState([\n  //   'hoveringId'\n  // ]),\n  hoveredConnector: function hoveredConnector() {\n    var _iteratorNormalCompletion9 = true;\n    var _didIteratorError9 = false;\n    var _iteratorError9 = undefined;\n\n    try {\n      for (var _iterator9 = this.internalNodes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n        var node = _step9.value;\n        var connectorPosition = this.getConnectorPosition(node);\n\n        for (var prop in connectorPosition) {\n          var entry = connectorPosition[prop];\n\n          if (Math.hypot(entry.x - this.cursorToChartOffset.x, entry.y - this.cursorToChartOffset.y) < 10) {\n            return {\n              position: prop,\n              node: node\n            };\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError9 = true;\n      _iteratorError9 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n          _iterator9.return();\n        }\n      } finally {\n        if (_didIteratorError9) {\n          throw _iteratorError9;\n        }\n      }\n    }\n\n    return null;\n  },\n  hoveredConnection: function hoveredConnection() {\n    var _this = this;\n\n    var _iteratorNormalCompletion10 = true;\n    var _didIteratorError10 = false;\n    var _iteratorError10 = undefined;\n\n    try {\n      var _loop2 = function _loop2() {\n        var line = _step10.value;\n        var distance = distanceOfPointToLine(line.sourceX, line.sourceY, line.destinationX, line.destinationY, _this.cursorToChartOffset.x, _this.cursorToChartOffset.y);\n\n        if (distance < 5 && between(line.sourceX - 2, line.destinationX + 2, _this.cursorToChartOffset.x) && between(line.sourceY - 2, line.destinationY + 2, _this.cursorToChartOffset.y)) {\n          var connections = _this.internalConnections.filter(function (item) {\n            return item.id === line.id;\n          });\n\n          return {\n            v: connections.length > 0 ? connections[0] : null\n          };\n        }\n      };\n\n      for (var _iterator10 = this.lines[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n        var _ret = _loop2();\n\n        if (_typeof(_ret) === \"object\") return _ret.v;\n      }\n    } catch (err) {\n      _didIteratorError10 = true;\n      _iteratorError10 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n          _iterator10.return();\n        }\n      } finally {\n        if (_didIteratorError10) {\n          throw _iteratorError10;\n        }\n      }\n    }\n\n    return null;\n  },\n  cursor: function cursor() {\n    if (this.connectingInfo.source || this.hoveredConnector) {\n      return \"crosshair\";\n    }\n\n    if (this.hoveredConnection != null) {\n      return \"pointer\";\n    }\n\n    return null;\n  }\n}), _defineProperty(_name$props$data$watc, \"watch\", {\n  internalNodes: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      this.renderNodes();\n      this.renderConnections();\n    }\n  },\n  internalConnections: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      this.renderConnections();\n    }\n  },\n  selectionInfo: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      this.renderSelection();\n    }\n  },\n  currentNodes: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      this.renderNodes();\n    }\n  },\n  currentConnections: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      this.renderConnections();\n    }\n  },\n  cursorToChartOffset: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      if (this.selectionInfo) {\n        this.renderSelection();\n      }\n    }\n  },\n  connectingInfo: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      this.renderConnections();\n    }\n  },\n  nodes: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      this.init();\n    }\n  },\n  connections: {\n    immediate: true,\n    deep: true,\n    handler: function handler() {\n      this.init();\n    }\n  }\n}), _name$props$data$watc);",{"version":3,"sources":["Flowchart.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div\n    id=\"chart\"\n    tabindex=\"0\"\n    :style=\"{ cursor: cursor }\"\n    @mousemove=\"handleChartMouseMove\"\n    @mouseup=\"handleChartMouseUp\"\n    @mousewheel=\"handleChartMouseWheel\"\n    @mousedown=\"handleChartMouseDown($event)\">\n    <span id=\"position\" class=\"unselectable\">\n      {{ cursorToChartOffset.x + \", \" + cursorToChartOffset.y }}\n    </span>\n    <span v-if=\"regexContentFlag\" id=\"regexPosition\" class=\"unselectable\">\n      {{\"regexContent: \" + regexContent}}\n    </span>\n    <svg id=\"svg\" ref=\"flowChartCanvas\">\n      <rect class=\"selection\" height=\"0\" width=\"0\"></rect>\n    </svg>\n  </div>\n</template>\n<style lang=\"less\" src=\"./index.less\"></style>\n<script>\nimport { line2, lineTo } from \"../../utils/svg\";\nimport { mapState, mapMutations } from 'vuex'\nimport * as d3 from \"d3\";\n\nimport {\n  roundTo20,\n  between,\n  distanceOfPointToLine, \n  getEdgeOfPoints,\n  pointRectangleIntersection,\n} from \"../../utils/math\";\nimport render from \"./render\";\n\nexport default {\n  name: \"flowchart\",\n  props: {\n    nodes: {\n      type: Array,\n      default: () => [],\n    },\n    connections: {\n      type: Array,\n      default: () => [],\n    },\n    width: {\n      type: [String, Number],\n      default: 800,\n    },\n    height: {\n      type: [String, Number],\n      default: 600,\n    },\n    readonly: {\n      type: Boolean,\n      default: false,\n    },\n    excludeShownAttrArray: {\n      type: Array,\n      default: [],\n    }\n  },\n  data() {\n    return {\n      internalNodes: [],\n      internalConnections: [],\n      connectingInfo: {\n        source: null,\n        sourcePosition: null,\n      },\n      selectionInfo: null,\n      currentNodes: [],\n      currentConnections: [],\n      /**\n       * Mouse position(relative to chart div)\n       */\n      cursorToChartOffset: { x: 0, y: 0 },\n      clickedOnce: false,\n      pathClickedOnce: false,\n      /**\n       * lines of all internalConnections\n       */\n      lines: [],\n      canvasId: \"svg\",\n      regexContent: \"\",\n      regexContentFlag: false,\n    };\n  },\n  watch: {\n    regexContentState: function(){\n        this.regexContent = sysDatasetObj.returnRegexContent(this.curRegexIndex)   \n    }\n  },\n  computed: {\n    ...mapState([\n      'regexContentState',\n      'curRegexIndex'\n    ]),\n  },\n  methods: {\n    ...mapMutations([\n      'UPDATE_VISVIEW',\n      'UPDATE_CURRENT_REGEX',\n      'UPDATE_CONNECTION'\n    ]),\n    addComponent(){\n      let tmpNode = {type: 'query', color: '#ff7f00', name: 'query'}\n      this.$emit(\"addComponent\", tmpNode)\n    },\n    add(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.internalNodes.push(node);\n    },\n    editCurrent() {\n      if (this.currentNodes.length === 1) {\n        this.editNode(this.currentNodes[0]);\n      } else if (this.currentConnections.length === 1) {\n        this.editConnection(this.currentConnections[0]);\n      }\n    },\n    editNode(node) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editnode\", node);\n    },\n    editConnection(connection) {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"editconnection\", connection);\n    },\n    refresh() {\n      console.log('refresh whole view')\n    },\n    handleChartMouseWheel(event) {\n      event.stopPropagation();\n      event.preventDefault();\n      if (event.ctrlKey) {\n        let svg = document.getElementById(\"svg\");\n        let zoom = parseFloat(svg.style.zoom || 1);\n        if (event.deltaY > 0 && zoom === 0.1) {\n          return;\n        }\n        zoom -= event.deltaY / 100 / 10;\n        svg.style.zoom = zoom;\n      }\n    },\n    async handleChartMouseUp() {\n      if (this.connectingInfo.source) {\n        if (this.hoveredConnector) {\n          if (this.connectingInfo.source.id !== this.hoveredConnector.node.id) {\n            // Node can't connect to itself\n            let tempId = +new Date();\n            let conn = {\n              source: {\n                id: this.connectingInfo.source.id,\n                position: this.connectingInfo.sourcePosition,\n              },\n              destination: {\n                id: this.hoveredConnector.node.id,\n                position: this.hoveredConnector.position,\n              },\n              id: tempId,\n              type: \"pass\",\n              name: \"Pass\",\n            };\n            let tmpSource = this.internalNodes.filter((item) => item.id === conn['source']['id'])[0]\n            let tmpDestination = this.internalNodes.filter((item) => item.id === conn['destination']['id'])[0]\n            sysDatasetObj.DataOut2DataIn(tmpSource['regexIndex'], tmpDestination['regexIndex'])\n            this.UPDATE_CONNECTION(tmpDestination['regexIndex'])\n            \n            this.internalConnections.push(conn)\n          }\n        }\n        this.connectingInfo.source = null;\n        this.connectingInfo.sourcePosition = null;\n      }\n      if (this.selectionInfo) {\n        this.selectionInfo = null;\n      }\n      this.regexContentFlag = false\n      \n    },\n    async handleChartMouseMove(event) {\n      // calc offset of cursor to chart\n      let svg = document.getElementById(\"svg\");\n      let zoom = svg.style.zoom; // the size ratio of the whole canvas\n      if (zoom.length == 0) {\n        zoom = 1\n      }\n      zoom = parseFloat(zoom)\n      let boundingClientRect = event.currentTarget.getBoundingClientRect();\n      let actualX = event.pageX - boundingClientRect.left - window.scrollX;  \n      actualX = actualX / zoom\n      this.cursorToChartOffset.x = Math.trunc(actualX);\n      let actualY = event.pageY - boundingClientRect.top - window.scrollY;\n      actualY = actualY / zoom\n      this.cursorToChartOffset.y = Math.trunc(actualY);\n      if (this.connectingInfo.source) {\n        await this.renderConnections();\n\n        d3.selectAll(\"#svg .connector\").classed(\"active\", true);\n\n        let sourceOffset = this.getNodeConnectorOffset(\n          this.connectingInfo.source.id,\n          this.connectingInfo.sourcePosition\n        );\n        let destinationPosition = this.hoveredConnector\n          ? this.hoveredConnector.position\n          : null;\n        this.arrowTo(\n          sourceOffset.x,\n          sourceOffset.y,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y,\n          this.connectingInfo.sourcePosition,\n          false,\n          destinationPosition\n        );\n      }\n    },\n    handleChartMouseDown(event) {\n      if (event.ctrlKey) {\n        return;\n      }\n      this.selectionInfo = { x: event.offsetX, y: event.offsetY };\n    },\n    getConnectorPosition(node) {\n      const halfWidth = node.width / 2;\n      const halfHeight = node.height / 2;\n      let top = { x: node.x + halfWidth, y: node.y };\n      let left = { x: node.x, y: node.y + halfHeight };\n      let bottom = { x: node.x + halfWidth, y: node.y + node.height };\n      let right = { x: node.x + node.width, y: node.y + halfHeight };\n      return { left, right, top, bottom };\n    },\n    renderSelection() {\n      let that = this;\n      // render selection rectangle\n      if (that.selectionInfo) {\n        that.currentNodes.splice(0, that.currentNodes.length);\n        that.currentConnections.splice(0, that.currentConnections.length);\n        let edge = getEdgeOfPoints([\n          { x: that.selectionInfo.x, y: that.selectionInfo.y },\n          { x: that.cursorToChartOffset.x, y: that.cursorToChartOffset.y },\n        ]);\n        let svg = d3.select(\"#svg\");\n        let rect = svg.select(\".selection\").classed(\"active\", true);\n        rect\n          .attr(\"x\", edge.start.x)\n          .attr(\"y\", edge.start.y)\n          .attr(\"width\", edge.end.x - edge.start.x)\n          .attr(\"height\", edge.end.y - edge.start.y);\n\n        that.internalNodes.forEach((item) => {\n          let points = [\n            { x: item.x, y: item.y },\n            { x: item.x, y: item.y + item.height },\n            { x: item.x + item.width, y: item.y },\n            { x: item.x + item.width, y: item.y + item.height },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge))\n          ) {\n            that.currentNodes.push(item);\n          }\n        });\n        that.lines.forEach((line) => {\n          let points = [\n            { x: line.sourceX, y: line.sourceY },\n            { x: line.destinationX, y: line.destinationY },\n          ];\n          if (\n            points.every((point) => pointRectangleIntersection(point, edge)) &&\n            that.currentConnections.every((item) => item.id !== line.id)\n          ) {\n            let connection = that.internalConnections.filter(\n              (conn) => conn.id === line.id\n            )[0];\n            that.currentConnections.push(connection);\n          }\n        });\n      } else {\n        d3.selectAll(\"#svg > .selection\").classed(\"active\", false);\n      }\n    },\n    renderConnections() {\n      let that = this;\n      return new Promise(function (resolve) {\n        that.$nextTick(function () {\n          d3.selectAll(\"#svg > g.connection\").remove();\n          // render lines\n          that.lines = [];\n          that.internalConnections.forEach((conn) => {\n            let sourcePosition = that.getNodeConnectorOffset(\n              conn.source.id,\n              conn.source.position\n            );\n            let destinationPosition = that.getNodeConnectorOffset(\n              conn.destination.id,\n              conn.destination.position\n            );\n            let colors = {\n              pass: \"#888888\",\n              reject: \"red\",\n            };\n            let connectionSelected = that.currentConnections.filter((item) => item === conn).length > 0\n            if (connectionSelected) {\n              colors = {\n                pass: \"#888888\",\n                reject: \"darkred\",\n              };\n            }\n            let result = that.arrowTo(\n              sourcePosition.x,\n              sourcePosition.y,\n              destinationPosition.x,\n              destinationPosition.y,\n              conn.source.position,\n              conn.destination.position,\n              connectionSelected,\n              colors[conn.type]\n            );\n            for (const path of result.paths) {\n              path.on(\"mousedown\", function () {\n                d3.event.stopPropagation();\n                if (that.pathClickedOnce) {\n                  that.editConnection(conn);\n                } else {\n                  let timer = setTimeout(function () {\n                    that.pathClickedOnce = false;\n                    clearTimeout(timer);\n                  }, 300);\n                  that.pathClickedOnce = true;\n                }\n                that.currentNodes.splice(0, that.currentNodes.length);\n                that.currentConnections.splice(0, that.currentConnections.length);\n                that.currentConnections.push(conn);\n              });\n            }\n            for (const line of result.lines) {\n              that.lines.push({\n                sourceX: line.sourceX,\n                sourceY: line.sourceY,\n                destinationX: line.destinationX,\n                destinationY: line.destinationY,\n                id: conn.id,\n              });\n            }\n          });\n          resolve();\n        });\n      });\n    },\n    renderNodes() {\n      let that = this;\n      return new Promise(function (resolve) {\n        d3.selectAll(\"#svg > g.node\").remove();\n\n        // render nodes\n        that.internalNodes.forEach((node) => {\n          that.renderNode(\n            node,\n            that.currentNodes.filter((item) => item === node).length > 0\n          );\n        });\n\n        resolve();\n      });\n    },\n    getNodeConnectorOffset(nodeId, connectorPosition) {\n      let node = this.internalNodes.filter((item) => item.id === nodeId)[0];\n      return this.getConnectorPosition(node)[connectorPosition];\n    },\n    append(element) {\n      let svg = d3.select(\"#svg\");\n      return svg.insert(element, \".selection\");\n    },\n    guideLineTo(x1, y1, x2, y2) {\n      let g = this.append(\"g\");\n      g.classed(\"guideline\", true);\n      lineTo(g, x1, y1, x2, y2, 1, \"#a3a3a3\", [5, 3]);\n    },\n    arrowTo(x1, y1, x2, y2, startPosition, endPosition, connectionSelected, color) {\n      let g = this.append(\"g\");\n      g.classed(\"connection\", true);\n      if (connectionSelected) {\n        line2(g, x1, y1, x2, y2, startPosition, endPosition, 2.5, color || \"#a3a3a3\", true);\n      } else {\n        line2(g, x1, y1, x2, y2, startPosition, endPosition, 1, color || \"#a3a3a3\", true);\n      } \n      // a 5px cover to make mouse operation conveniently\n      return line2(\n        g,\n        x1,\n        y1,\n        x2,\n        y2,\n        startPosition,\n        endPosition,\n        5,\n        \"transparent\",\n        false\n      );\n    },\n    renderNode(node, isSelected) {\n      let that = this;\n      let g = that.append(\"g\").attr(\"cursor\", \"move\").classed(\"node\", true);\n\n      node.render = render;\n      node.render(g, node, isSelected, this.excludeShownAttrArray);\n\n      let drag = d3\n        .drag()\n        .on(\"start\", function () {\n          // handle mousedown\n          let isNotCurrentNode =\n            that.currentNodes.filter((item) => item === node).length === 0;\n          if (isNotCurrentNode) {\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentNodes.push(node);\n          }\n          // the drag event and click event is conflicted, \n          // so handle the drag start function of the selected nodes is equal to the double click event\n          if (that.clickedOnce) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.editNode(node);\n          } else {\n            that.regexContent = sysDatasetObj.returnRegexContent(node['regexIndex'])\n            that.regexContentFlag = true\n            that.UPDATE_CURRENT_REGEX(node['regexIndex'])\n            that.UPDATE_VISVIEW()\n            let timer = setTimeout(function () {\n              that.clickedOnce = false;\n              clearTimeout(timer);\n            }, 300);\n            that.clickedOnce = true;\n          }\n        })\n        .on(\"drag\", async function () {\n          if (that.readonly) {\n            return;\n          }\n\n          let zoom = parseFloat(document.getElementById(\"svg\").style.zoom || 1);\n          for (let currentNode of that.currentNodes) {\n            currentNode.x += d3.event.dx / zoom;\n            currentNode.y += d3.event.dy / zoom;\n          }\n\n          d3.selectAll(\"#svg > g.guideline\").remove();\n          let edge = that.getCurrentNodesEdge();\n          let expectX = Math.round(Math.round(edge.start.x) / 10) * 10;\n          let expectY = Math.round(Math.round(edge.start.y) / 10) * 10;\n          that.internalNodes.forEach((item) => {\n            if (\n              that.currentNodes.filter((currentNode) => currentNode === item)\n                .length === 0\n            ) {\n              if (item.x === expectX) {\n                // vertical guideline\n                if (item.y < expectY) {\n                  that.guideLineTo(\n                    item.x,\n                    item.y + item.height,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX,\n                    expectY + item.height,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n              if (item.y === expectY) {\n                // horizontal guideline\n                if (item.x < expectX) {\n                  that.guideLineTo(\n                    item.x + item.width,\n                    item.y,\n                    expectX,\n                    expectY\n                  );\n                } else {\n                  that.guideLineTo(\n                    expectX + item.width,\n                    expectY,\n                    item.x,\n                    item.y\n                  );\n                }\n              }\n            }\n          });\n        })\n        .on(\"end\", function () {\n          d3.selectAll(\"#svg > g.guideline\").remove();\n          for (let currentNode of that.currentNodes) {\n            currentNode.x = Math.round(Math.round(currentNode.x) / 10) * 10;\n            currentNode.y = Math.round(Math.round(currentNode.y) / 10) * 10;\n          }\n        });\n      g.call(drag);\n      g.on(\"mousedown\", function () {\n        // handle ctrl+mousedown\n        if (!d3.event.ctrlKey) {\n          return;\n        }\n        let isNotCurrentNode =\n          that.currentNodes.filter((item) => item === node).length === 0;\n        if (isNotCurrentNode) {\n          that.currentNodes.push(node);\n        } else {\n          that.currentNodes.splice(that.currentNodes.indexOf(node), 1);\n        }\n      });\n\n      let connectors = [];\n      let connectorPosition = this.getConnectorPosition(node);\n      for (let position in connectorPosition) {\n        let positionElement = connectorPosition[position];\n        let connector = g\n          .append(\"circle\")\n          .attr(\"cx\", positionElement.x)\n          .attr(\"cy\", positionElement.y)\n          .attr(\"r\", 4)\n          .attr(\"class\", \"connector\");\n        connector\n          .on(\"mousedown\", function () {\n            d3.event.stopPropagation();\n            if (node.type === \"end\" || that.readonly) {\n              return;\n            }\n            that.connectingInfo.source = node;\n            that.connectingInfo.sourcePosition = position;\n          })\n          .on(\"mouseup\", function () {\n            d3.event.stopPropagation();\n            if (that.connectingInfo.source) {\n              if (that.connectingInfo.source.id !== node.id) {\n                // Node can't connect to itself\n                let tempId = +new Date();\n                let conn = {\n                  source: {\n                    id: that.connectingInfo.source.id,\n                    position: that.connectingInfo.sourcePosition,\n                  },\n                  destination: {\n                    id: node.id,\n                    position: position,\n                  },\n                  id: tempId,\n                  type: \"pass\",\n                  name: \"Pass\",\n                };\n                that.internalConnections.push(conn);\n              }\n              that.connectingInfo.source = null;\n              that.connectingInfo.sourcePosition = null;\n            }\n          })\n          .on(\"mouseover\", function () {\n            connector.classed(\"active\", true);\n          })\n          .on(\"mouseout\", function () {\n            connector.classed(\"active\", false);\n          });\n        connectors.push(connector);\n      }\n      g.on(\"mouseover\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", true));\n      }).on(\"mouseout\", function () {\n        connectors.forEach((conn) => conn.classed(\"active\", false));\n      });\n    },\n    getCurrentNodesEdge() {\n      let points = this.currentNodes.map((node) => ({\n        x: node.x,\n        y: node.y,\n      }));\n      points.push(\n        ...this.currentNodes.map((node) => ({\n          x: node.x + node.width,\n          y: node.y + node.height,\n        }))\n      );\n      return getEdgeOfPoints(points);\n    },\n    save() {\n      if (this.readonly) {\n        return;\n      }\n      this.$emit(\"save\", this.internalNodes, this.internalConnections);\n    },\n    async remove() {\n      if (this.readonly) {\n        return;\n      }\n      if (this.currentConnections.length > 0) {\n        for (let conn of this.currentConnections) {\n          this.removeConnection(conn);\n        }\n        this.currentConnections.splice(0, this.currentConnections.length);\n      }\n      if (this.currentNodes.length > 0) {\n        for (let node of this.currentNodes) {\n          this.removeNode(node);\n        }\n        this.currentNodes.splice(0, this.currentNodes.length);\n      }\n    },\n    removeNode(node) {\n      let connections = this.internalConnections.filter(\n        (item) => item.source.id === node.id || item.destination.id === node.id\n      );\n      for (let connection of connections) {\n        this.internalConnections.splice(\n          this.internalConnections.indexOf(connection),\n          1\n        );\n      }\n      sysDatasetObj.deleteDataNode(node['regexIndex'])\n      this.internalNodes.splice(this.internalNodes.indexOf(node), 1);\n    },\n    removeConnection(conn) {\n      let index = this.internalConnections.indexOf(conn);\n      let tmpSource = this.internalNodes.filter((item) => item.id === conn['source']['id'])[0]\n      let tmpDestination = this.internalNodes.filter((item) => item.id === conn['destination']['id'])[0]\n      sysDatasetObj.deleteDataConnection(tmpSource['regexIndex'], tmpDestination['regexIndex'])\n      this.internalConnections.splice(index, 1);\n    },\n    moveCurrentNode(x, y) {\n      if (this.currentNodes.length > 0 && !this.readonly) {\n        for (let node of this.currentNodes) {\n          node.x += x;\n          node.y += y;\n        }\n      }\n    },\n    init() {\n      let that = this;\n      that.internalNodes.splice(0, that.internalNodes.length);\n      that.internalConnections.splice(0, that.internalConnections.length);\n      that.nodes.forEach((node) => {\n        let newNode = Object.assign({}, node);\n        newNode.width = newNode.width || 120;\n        newNode.height = newNode.height || 60;\n        that.internalNodes.push(newNode);\n      });\n      that.connections.forEach((connection) => {\n        that.internalConnections.push(JSON.parse(JSON.stringify(connection)));\n      });\n    },\n    ...mapMutations([\n      'UPDATE_HOVERING_ID'\n    ])\n  },\n  mounted() {\n    let that = this;\n    that.init();\n    document.onkeydown = function (event) {\n      switch (event.keyCode) {\n        case 37:\n          that.moveCurrentNode(-10, 0);\n          break;\n        case 38:\n          that.moveCurrentNode(0, -10);\n          break;\n        case 39:\n          that.moveCurrentNode(10, 0);\n          break;\n        case 40:\n          that.moveCurrentNode(0, 10);\n          break;\n        case 27:\n          that.currentNodes.splice(0, that.currentNodes.length);\n          that.currentConnections.splice(0, that.currentConnections.length);\n          break;\n        case 65:\n          if (document.activeElement === document.getElementById(\"chart\")) {\n            that.currentNodes.splice(0, that.currentNodes.length);\n            that.currentConnections.splice(0, that.currentConnections.length);\n            that.currentNodes.push(...that.internalNodes);\n            that.currentConnections.push(...that.internalConnections);\n            event.preventDefault();\n          }\n          break;\n        // delete the selected item\n        case 8:\n        // case 46:\n        //   that.remove();\n        //   break;\n        default:\n          break;\n      }\n    };\n  },\n  created() {},\n  computed: {\n    // ...mapState([\n    //   'hoveringId'\n    // ]),\n    hoveredConnector() {\n      for (const node of this.internalNodes) {\n        let connectorPosition = this.getConnectorPosition(node);\n        for (let prop in connectorPosition) {\n          let entry = connectorPosition[prop];\n          if (\n            Math.hypot(\n              entry.x - this.cursorToChartOffset.x,\n              entry.y - this.cursorToChartOffset.y\n            ) < 10\n          ) {\n            return { position: prop, node: node };\n          }\n        }\n      }\n      return null;\n    },\n    hoveredConnection() {\n      for (const line of this.lines) {\n        let distance = distanceOfPointToLine(\n          line.sourceX,\n          line.sourceY,\n          line.destinationX,\n          line.destinationY,\n          this.cursorToChartOffset.x,\n          this.cursorToChartOffset.y\n        );\n        if (\n          distance < 5 &&\n          between(\n            line.sourceX - 2,\n            line.destinationX + 2,\n            this.cursorToChartOffset.x\n          ) &&\n          between(\n            line.sourceY - 2,\n            line.destinationY + 2,\n            this.cursorToChartOffset.y\n          )\n        ) {\n          let connections = this.internalConnections.filter(\n            (item) => item.id === line.id\n          );\n          return connections.length > 0 ? connections[0] : null;\n        }\n      }\n      return null;\n    },\n    cursor() {\n      if (this.connectingInfo.source || this.hoveredConnector) {\n        return \"crosshair\";\n      }\n      if (this.hoveredConnection != null) {\n        return \"pointer\";\n      }\n      return null;\n    },\n  },\n  watch: {\n    internalNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n        this.renderConnections();\n      },\n    },\n    internalConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    selectionInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderSelection();\n      },\n    },\n    currentNodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderNodes();\n      },\n    },\n    currentConnections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    cursorToChartOffset: {\n      immediate: true,\n      deep: true,\n      handler() {\n        if (this.selectionInfo) {\n          this.renderSelection();\n        }\n      },\n    },\n    connectingInfo: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.renderConnections();\n      },\n    },\n    nodes: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.init();\n      },\n    },\n    connections: {\n      immediate: true,\n      deep: true,\n      handler() {\n        this.init();\n      },\n    },\n  },\n};\n</script>\n"],"sourceRoot":"src/components/flowchart"}]}